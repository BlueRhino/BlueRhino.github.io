<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=6.0.6">


  <link rel="mask-icon" href="/favicon.ico?v=6.0.6" color="#222">


  <link rel="manifest" href="/favicon.ico">


  <meta name="msapplication-config" content="/favicon.ico" />







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  

<meta name="description" content="概述在java.util.concurrent.locks.Lock详解一文中简单的描述了JDK中JUC包对于Lock接口的定义，并且简单的对比了Lock接口及Java关键字synchronized的异同。本文主要研究Lock接口的常用实现ReentrantLock，本文主要分为以下几部分：  什么是重入？ ReentrantLock的实现分析； Condition对象介绍； ReentrantL">
<meta name="keywords" content="Java,并发,重入锁">
<meta property="og:type" content="article">
<meta property="og:title" content="细谈重入锁ReentrantLock">
<meta property="og:url" content="http://bluerhino.github.io/2018/04/26/细谈重入锁ReentrantLock/index.html">
<meta property="og:site_name" content="闲情记趣">
<meta property="og:description" content="概述在java.util.concurrent.locks.Lock详解一文中简单的描述了JDK中JUC包对于Lock接口的定义，并且简单的对比了Lock接口及Java关键字synchronized的异同。本文主要研究Lock接口的常用实现ReentrantLock，本文主要分为以下几部分：  什么是重入？ ReentrantLock的实现分析； Condition对象介绍； ReentrantL">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png">
<meta property="og:updated_time" content="2018-04-26T14:29:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细谈重入锁ReentrantLock">
<meta name="twitter:description" content="概述在java.util.concurrent.locks.Lock详解一文中简单的描述了JDK中JUC包对于Lock接口的定义，并且简单的对比了Lock接口及Java关键字synchronized的异同。本文主要研究Lock接口的常用实现ReentrantLock，本文主要分为以下几部分：  什么是重入？ ReentrantLock的实现分析； Condition对象介绍； ReentrantL">
<meta name="twitter:image" content="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png">






  <link rel="canonical" href="http://bluerhino.github.io/2018/04/26/细谈重入锁ReentrantLock/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>细谈重入锁ReentrantLock | 闲情记趣</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">闲情记趣</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Not a porter but a programmer</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">22</span>
      </a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">5</span>
      </a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">8</span>
      </a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bluerhino.github.io/2018/04/26/细谈重入锁ReentrantLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BlueRhino">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闲情记趣">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">细谈重入锁ReentrantLock</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T22:26:54+08:00">2018-04-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/并发/" itemprop="url" rel="index"><span itemprop="name">并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/04/26/细谈重入锁ReentrantLock/" class="leancloud_visitors" data-flag-title="细谈重入锁ReentrantLock">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png" rel="gallery_cjggn7wmj000ks36hlgst6sm3"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在<a href="/2017/10/23/java-util-concurrent-locks-Lock详解/" title="java.util.concurrent.locks.Lock详解">java.util.concurrent.locks.Lock详解</a>一文中简单的描述了JDK中JUC包对于Lock接口的定义，并且简单的对比了Lock接口及Java关键字synchronized的异同。本文主要研究Lock接口的常用实现ReentrantLock，本文主要分为以下几部分：</p>
<ol>
<li>什么是重入？</li>
<li>ReentrantLock的实现分析；</li>
<li>Condition对象介绍；</li>
<li>ReentrantLock性能分析；</li>
<li>ReentrantLock使用场景；</li>
<li>总结。<a id="more"></a>
</li>
</ol>
<h1 id="什么是重入？"><a href="#什么是重入？" class="headerlink" title="什么是重入？"></a>什么是重入？</h1><p>ReentrantLock通过类名称可顾名思义，由Reentrant及Lock两部分组成。Lock略去不谈，观察Reentrant单词可以简单将其拆为前缀re及主体entrant，即re：再，entrant：进入。<br>显而易见重入就是再次进入的意思，在并发编程中具体指某线程已经获取了一个锁后，再次请求这个锁时可以获得该锁而不会阻塞。</p>
<h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>在某线程递归调用某函数时较容易观察重入锁与非重入锁区别，如以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//将i重置</span></span><br><span class="line">          i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        reentrantLockTest.callBack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>callBack函数使用synchronized关键字进行同步控制，synchronized关键字可以确保同时只有一个线程可进入临界区，并且由于synchronized支持重入，故上面的代码可以正常运行（synchronized关键字实现原理以后再做补充）。</p>
<h2 id="简单非重入锁"><a href="#简单非重入锁" class="headerlink" title="简单非重入锁"></a>简单非重入锁</h2><p>现为Lock接口编写一个简单实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueRhinoLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlueRhinoLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他接口函数略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>简单起见，该锁基于BlockingQueue将capacity取值为1，实现了一个不可重入的排它锁。如以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    BlueRhinoLock blueRhinoLock = <span class="keyword">new</span> BlueRhinoLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blueRhinoLock.lock();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blueRhinoLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; reentrantLockTest.callBack()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此段代码不使用synchronized关键字而使用BlueRhinoLock进行同步控制，在任一线程运行到<code>blueRhinoLock.lock();</code><br>语句后获取锁，则所有其他线程需要在此等待。但由于本段代码中存在回调，同一线程会在回调callBack时再次运行到<code>blueRhinoLock.lock();</code><br>代码行时则由于无法获取锁进入等待，则形成由于锁不支持重入而形成死锁。运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line"><span class="comment">//无法继续打印</span></span><br></pre></td></tr></table></figure></p>
<h2 id="简单重入锁"><a href="#简单重入锁" class="headerlink" title="简单重入锁"></a>简单重入锁</h2><p>为了解决以上死锁问题，需要对以上的简单锁进行改进使其支持重入。主要需要完成对于同一线程请求锁时，若当前线程已经拥有当前锁且没有释放的情况下，直接继续执行，根据以上思路配合使用ThreadLocall可以将代码修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueRhinoReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlueRhinoReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(threadLocal.get() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object o = blockingQueue.take();</span><br><span class="line">                threadLocal.set(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object o = threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span>(o == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意以上为测试代码，没有充分考虑安全性问题</strong></p>
<p>以上代码使用ThreadLocal记录当前线程是否已经获取锁，解决了重入问题。调用代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    BlueRhinoReentrantLock blueRhinoLock = <span class="keyword">new</span> BlueRhinoReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blueRhinoLock.lock();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blueRhinoLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; reentrantLockTest.callBack()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ReentrantLock的实现分析"><a href="#ReentrantLock的实现分析" class="headerlink" title="ReentrantLock的实现分析"></a>ReentrantLock的实现分析</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>以上代码简单演示了重入锁与非重入锁的区别，但是代码实现非常粗糙，本节主要深入到JDK8中ReentrantLock类的实现，学习生产级别的代码如何实现重入锁。<br>JDK8中ReentrantLock代码包括注释为763行，作者为大神<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>。其UML图为：<img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png" alt=""><br>通过UML可以看出与ReentrantLock与其相关类（接口）之间的重要关系：</p>
<ol>
<li>ReentrantLock实现了Lock接口（应该说是废话）；</li>
<li>抽象类Sync是ReentrantLock重要组成部分；</li>
<li>FairSync及NonFairSync均继承于Sync；</li>
<li>Sync继承抽象类了AbstractQueuedSynchronizer；</li>
<li>AbstractQueuedSynchronizer继承了抽象类AbstractOwnableSynchronizer。</li>
</ol>
<p>下文从一些重要的函数入手开始研究其实现。</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ReentrantLock只有两个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数均比较简单，都创建了一个Sync类型的实例变量，由于Sync是抽象类，实际创建的为其子类，默认为NonfairSync，在带boolean参数的构造函数中可以使用参数值指定创建NonfairSync或FairSync对象。源码中对于Sync的介绍为：</p>
<blockquote>
<p>Base of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock.</p>
</blockquote>
<p>重点在于使用AQS（AbstractQueuedSynchronizer）记录锁的获取数量，由此可见AbstractQueuedSynchronizer为ReentrantLock实现提供了重要支持。在前面的文章<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>介绍了AQS相关技术。</p>
<h3 id="lock函数"><a href="#lock函数" class="headerlink" title="lock函数"></a>lock函数</h3><p>lock函数为Lock接口的核心函数之一，在Lock接口中对于该函数的注释为:</p>
<blockquote>
<p>Acquires the lock.<br>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
</blockquote>
<p>在ReentrantLock的实现中对于Lock函数也有注释：</p>
<blockquote>
<p>Acquires the lock.<br>Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one.<br>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.<br>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</p>
</blockquote>
<p>对比两段注释可见，都表明该函数主要功能为“获取锁”。<br>在Lock接口中仅仅规定如果当前线程无法获取锁则进入无法调度的休眠状态直到获得锁。<br>在ReentrantLock实现时细化了其实现细节，说明在当前线程获得锁后，将其锁计数器置为1，以后持有该锁的线程再次申请锁则将计数器加1并且立即返回，如当前线程无法获取锁则进入无法调度的休眠状态直道获取锁，并且在获取锁的同时将锁计数器置为1。现在具体看实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可见直接调用了<code>sync</code>的<code>lock</code>函数，再进入<code>lock</code>函数进行研究。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sync</code>的<code>lock</code>函数是一个抽象函数，在两个子类<code>NonfairSync</code>、<code>FairSync</code>中进行了不同实现，上一节构造函数中已经看见过这两个类了，分别代表非公平算法实现的同步器及公平算法实现的同步器，无参数构造函数默认创建的是非公平的同步器。  </p>
<h4 id="NonfairSync中的lock"><a href="#NonfairSync中的lock" class="headerlink" title="NonfairSync中的lock"></a><code>NonfairSync</code>中的<code>lock</code></h4><p>先考察<code>NonfairSync</code>中的<code>lock</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入函数首先使用<code>compareAndSetState</code>函数进行设置，该函数实际是从<code>AbstractQueuedSynchronizer</code>类继承而来，其功能为使用CAS操作<strong>原子</strong>的设置对象中一个名为<code>state</code>的<code>int</code>型变量。<br>如果实际值与期望值相等均为0，说明当前锁没有被持有，则直接将<code>state</code>设置为1，继续调用<code>setExclusiveOwnerThread</code>函数将当前锁的所有者设置为当前线程。<br>如果实际值与期望值0不相等则说明当前锁已经被别的线程获取，需要使用<code>acquire</code>函数进行锁的获取，该函数仍然是从<code>AbstractQueuedSynchronizer</code>类继承而来其过程如下：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/AbstractQueuedSynchronizer_acquire.png" alt=""><br>根据流程图继续进行分析，进入<code>acquire</code>函数首先调用<code>tryAcquire</code>再次尝试获取锁，这是因为在线程从使用<code>compareAndSetState</code>设置<code>state</code>失败到当前时刻，原来占用锁的的线程可能已经释放了锁，如果这次尝试成功可以较大的减少将线程加入等待队列的性能消耗。根据前文<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>的介绍，<code>tryAcquire</code>函数是<code>AQS</code>类的成员函数，使用继承<code>AQS</code>类的方式实现同步器时需要在子类覆盖<code>tryAcquire</code>方法。在<code>ReentrantLock</code>中对于<code>tryAcquire</code>调用会根据当前锁是否公平锁，而最终调用<code>NonfairSync</code>或<code>FairSync</code>对象的<code>tryAcquire</code>方法。<br>由于本处分析<code>NonfairSync</code>的<code>lock</code>函数，则继续查看<code>NonfairSync</code>的<code>tryAcquire</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>其最终调用<code>nonfairTryAcquire</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要完成如下逻辑：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/%E9%87%8D%E5%85%A5%E9%94%81tryAcquire.png" alt=""></p>
<ol>
<li>获取当前线程对象及当前锁的状态值；</li>
<li>如果当前锁的状态值为0，则说明当前没有线程获取锁，使用CAS方式设置锁的状态为acquires（根据上文参数，此处为1）；如果不为0说明已有线程获取了锁，直接跳转到第5步；</li>
<li>如果设置成功，说明获取锁成功，则直接将当前锁的排他所有者线程设置为当前线程（由于第二步CAS设置只可能有一个线程成功，此处代码不需要作临界区保护）；</li>
<li>如果设置不成功，说明同一时刻有其他线程调用<code>compareAndSetState</code>，并且获得成功，则当前线程竞争锁失败直接返回false；</li>
<li>当前状态值不为0，需要继续判断以获取锁的线程是不是当前线程：  <ol>
<li>如果是，说明当前是同一线程重入的获取锁，则将当前锁状态加acquires（根据上文参数，此处为1），之后锁状态如果溢出，抛出异常，否则将锁的状态设置为新的值，返回true；</li>
<li>如果不是，尝试获取锁失败，直接返回false</li>
</ol>
</li>
</ol>
<p>以上第5.1步逻辑是实现重入的关键代码。<br>完成<code>tryAcquire</code>调用后，如果获取锁失败，则将当前线程封装为等待节点加入等待队列中。后续详细操作主要由<code>AQS</code>完成，可参考<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>。</p>
<h4 id="FairSync中的lock"><a href="#FairSync中的lock" class="headerlink" title="FairSync中的lock"></a><code>FairSync</code>中的<code>lock</code></h4><p>继续研究<code>FairSync</code>中的<code>lock</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>为方便比较将<code>NonfairSync</code>的<code>lock</code>拷贝下来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比代码可见公平锁实现较非公平锁简单，其直接调用<code>acquire</code>函数，<strong>第一次放弃插队的机会</strong>。而<code>acquire</code>函数如上文分析，最开始会调用<code>FairSync</code>类实现的<code>tryAcquire</code>函数，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比非公平锁代码，其实现最大逻辑区别在于第五行，公平锁实现时，在当前锁没有被其他线程获取时，会判断当前等待队列是否有等待锁的线程，如果没有才会获取锁，否则直接返回失败，在此处<strong>第二次放弃插队机会</strong>，由此保证线程获取锁的顺序一定与申请锁的等待时间相同。</p>
<h3 id="lockInterruptibly函数"><a href="#lockInterruptibly函数" class="headerlink" title="lockInterruptibly函数"></a>lockInterruptibly函数</h3><p><code>lockInterruptibly</code>函数是前文<code>lock</code>函数的可中断版本，查看源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数通过调用<code>AQS</code>类的<code>acquireInterruptibly</code>函数实现，继续查看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数实现逻辑与<code>lock</code>函数调用的<code>AQS</code>类的<code>lock</code>函数基本相同，主要增加了对线程中断的判断。进入函数首先判断当前线程是否已经中断，中断后则直接抛出中断异常，停止获取锁。如果没有被中断，则调用<code>tryAcquire</code>尝试获取锁，如果获取锁失败则进入<code>doAcquireInterruptibly</code>函数，该函数代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比<code>lock</code>函数调用的<code>acquireQueued</code>函数，主要区别在于第16行，如果在阻塞过程中被中断直接抛出中断异常到上层函数，并且取消当前等待节点。</p>
<h3 id="tryLock函数"><a href="#tryLock函数" class="headerlink" title="tryLock函数"></a>tryLock函数</h3><p><code>tryLock</code>函数尝试获取锁，与<code>lock</code>函数不同在于，该函数不阻塞，如果函数锁成功则返回true，否则直接返回false。</p>
<h3 id="tryLock-long-timeout-TimeUnit-unit-函数"><a href="#tryLock-long-timeout-TimeUnit-unit-函数" class="headerlink" title="tryLock(long timeout, TimeUnit unit)函数"></a>tryLock(long timeout, TimeUnit unit)函数</h3><p>该函数与<code>lock</code>函数逻辑相似，主要区别在于调用<code>LockSupport</code>工具类时使用<code>parkNanos</code>函数，指定等待时间。该函数在获取到锁或者达到过期时间时返回，获取锁则返回true，否则返回false。</p>
<h3 id="unlock函数"><a href="#unlock函数" class="headerlink" title="unlock函数"></a>unlock函数</h3><p>unlock函数用于释放锁，其调用syn.release函数，代码在<code>AQS</code>中实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其逻辑为调用<code>tryRelease</code>函数释放锁，在释放成功后唤醒当前头结点的后续等待节点。<code>tryRelease</code>在<code>AQS</code>中没有具体实现，在<code>ReentrantLock</code>类的内部工具类<code>Syn</code>中实现，代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑为：</p>
<ol>
<li>获取当前加锁状态，并将其减少releases(此处为1);</li>
<li>判断当前线程是否是获取锁的线程，如果当前线程没有获取锁则直接抛出异常;</li>
<li>若没有异常则需判断当前的加锁状态是否为0，此步与每次重入加锁状态加1对应，如果当前加锁状态已经为0，表示当前线程已经释放锁，则重新设置锁的持有线程为空，返回<code>true</code>，上文<code>release</code>函数不唤醒后续节点;</li>
<li>若加锁状态不为0，则更新加锁状态，返回<code>false</code>，上文<code>release</code>函数不唤醒后续节点。</li>
</ol>
<h3 id="newCondition函数"><a href="#newCondition函数" class="headerlink" title="newCondition函数"></a>newCondition函数</h3><p>该函数用于返回一个<code>Condition</code>接口实例，该类在<code>AQS</code>中有相关实现<code>ConditionObject</code>，由于<code>ConditionObject</code>为<code>AQS</code>非静态内部类，故通过调用<code>newCondition</code>函数创建的<code>Condition</code>接口实例会与当前的<code>AQS</code>对象自动关联起来（此处可参考非静态内部类特点）。对于<code>Condition</code>接口下一节再详细介绍。</p>
<h2 id="Condition对象介绍"><a href="#Condition对象介绍" class="headerlink" title="Condition对象介绍"></a>Condition对象介绍</h2><p><code>Condition</code>接口主要用于多线程加锁环境下，不同线程之间的协作。提供的核心方法为<code>await</code>及<code>signal</code>，语义为等待和通知。参考使用代码为：<br><span id="BoundedBuffer"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">     <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">     <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></span></p>
<p>以上代码引用自JDK8的Condition注释，实现了一个简单的有界缓存。主要包括存和取两个函数，由于可能使用与多线程环境，类中定义了一个重入锁进行对象属性的包括，保证同一时刻最多仅有一个线程可对有界缓存进行操作。但在缓存使用过程中，可能出现存入对象时有界队列已满，或取对象时队列还是空这两种情况。<br>当缓存在插入对象时，如队列已满则阻塞等待缓存有空间后继续插入；在读取对象时，如缓存为空则阻塞等待直到缓存有新的元素插入。<br>为实现以上功能，该段代码使用了使用<code>lock.newCondition()</code>创建notFull，notEmpty两个<code>Condition</code>对象，分别表示当前缓存非满和非空，在线程满时调用<code>notFull.await()</code>阻塞等待，直到缓存有空间后调用<code>notFull.signal()</code>唤醒等待线程，<code>notEmpty</code>用法类似。<br>那<code>Condition</code>对象是如何完成以上功能？与<code>Object</code>提供的<code>wait</code>及<code>notify</code>函数又有何区别？  </p>
<h3 id="Condition对象实现"><a href="#Condition对象实现" class="headerlink" title="Condition对象实现"></a>Condition对象实现</h3><p>通过以上示例可以学习到Condition接口的两个主要函数的用法，现在通过观察其代码实现学习具体实现逻辑。</p>
<h4 id="await函数实现"><a href="#await函数实现" class="headerlink" title="await函数实现"></a>await函数实现</h4><p>本处查看<code>AQS</code>类中<code>Condition</code>接口的实现类<code>ConditionObject</code>中await函数的实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码发现该函数主要逻辑为：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/Condition-await.png" alt=""><br>其中释放锁时相当于将当前节点从<code>AQS</code>的头节点移除。<br>使用<code>await</code>需要注意需要在当前线程获取锁后再调用，否则在释放锁时会抛出<code>IllegalMonitorStateException</code>异常，且在增加等待队列时会调用<code>unlinkCancelledWaiters</code>函数，该函数并不是线程安全的，这也要求调用该函数时需要首先获取锁。<br>另外在中断方面可以发现如果在<code>Condition</code>对象的等待队列中被中断，当前等待节点会从<code>Condition</code>对象的等待队列中被移除，但是仍然会将自己添加到<code>AQS</code>的等待队列中继续尝试获取锁。所以调用<code>await</code>函数后，即使等待线程被中断也不会立即抛出中断异常，仍然需要等到其获取到锁后才能根据不同中断处理模式进行中断处理。</p>
<h4 id="signal函数实现"><a href="#signal函数实现" class="headerlink" title="signal函数实现"></a>signal函数实现</h4><p>此处仍然查看<code>AQS</code>类中<code>ConditionObject</code>中<code>signal</code>的实现代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码首先调用<code>isHeldExclusively</code>函数判断当前线程是否排他的持有当前锁，如果不存在则直接抛出<code>IllegalMonitorStateException</code>异常。如果持有锁则调用<code>doSignal</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>此段代码逻辑也比较简单，首先将<code>ConditionObject</code>的等待节点的头结点设置为待转移节点的后续节点，调用<code>transferForSignal</code>方法将待转移节点附到<code>AQS</code>等待队列的队尾。这里需要注意的是<code>transferForSignal</code>函数的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数首先将节点状态从<code>Node.CONDITION</code>设置为无状态，如果当前状态不为<code>Node.CONDITION</code>则返回上层函数，继续设置下一个节点。将节点设置为无状态后将其加入<code>AQS</code>等待队列，并且判断前置节点状态，如果前置节点已经被取消，则唤醒当前节点中阻塞的线程。根据<code>Condition</code>实现可知，当前节点阻塞的线程必然在<code>await</code>函数的<code>LockSupport.park(this)</code>行阻塞，如果发现其前驱节点已经取消则直接唤醒该线程，此处需要注意唤醒此线程并不会让该线程直接获取锁，该线程仍然需要等待获取锁。<br>对于<code>Condition</code>对象的其他函数核心实现逻辑相似，不在赘述。</p>
<h4 id="对比Object的wait及notify函数"><a href="#对比Object的wait及notify函数" class="headerlink" title="对比Object的wait及notify函数"></a>对比Object的wait及notify函数</h4><p>根据上文分析<code>Condition</code>类的<code>await</code>及<code>signal</code>函数与<code>Object</code>类的<code>wait</code>及<code>notify</code>功能似乎非常类似，此处进行两种实现的对比。 </p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>所属类或接口</th>
<th>功能</th>
<th>使用条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait</td>
<td>Object</td>
<td>阻塞等待其他线程调用notify</td>
<td>需要先使用synchronized获取调用对象的锁</td>
</tr>
<tr>
<td>notify</td>
<td>Object</td>
<td>使被wait阻塞的线程进度调度</td>
<td>需要先使用synchronized获取调用对象的锁</td>
</tr>
<tr>
<td>await</td>
<td>Condition</td>
<td>阻塞等待其他线程调用signal</td>
<td>需要先获取Condition对象关联的锁对象代表的锁</td>
</tr>
<tr>
<td>signal</td>
<td>Condition</td>
<td>使被await阻塞的线程进度调度</td>
<td>需要先获取Condition对象关联的锁对象代表的锁</td>
</tr>
</tbody>
</table>
<p>直接查看发现以上两种线程间交互方式似乎没有明显不同，但在使用中<code>await</code>及<code>notify</code>方式明细较为灵活，因为一个<code>Lock</code>对象可以创建多个<code>Condition</code>对象用于说明在同一互斥资源上不同的等待条件，如上文<a href="#BoundedBuffer"><code>BoundedBuffer缓存示例代码</code></a>，如果使用<code>wait</code>配合<code>synchronized</code>进行实现，则必须同时唤醒插入及读取队列，并且根据判断，总有一个函数需要继续阻塞等待，效率及灵活性都较差。</p>
<h1 id="ReentrantLock性能分析"><a href="#ReentrantLock性能分析" class="headerlink" title="ReentrantLock性能分析"></a>ReentrantLock性能分析</h1><p>本文没有针对重入锁性能进行深入测试，参考<a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a>一书总结如下：<code>ReentrantLock</code>与内置锁<code>synchronized</code>在JAVA6之后性能差距不大。<code>ReentrantLock</code>锁的公平实现高并发性能明显低于非公平实现，针对代码分析，造成这种原因在于公平锁在高度竞争条件下几乎所有线程都会经过排队及上下文切换（即经过park函数阻塞及unpark函数唤醒），而非公平锁由于可能存在插队的情况，线程上下文切换次数明显少于公平锁，这是是的非公平锁性能更好的主要原因。</p>
<h1 id="ReentrantLock使用场景"><a href="#ReentrantLock使用场景" class="headerlink" title="ReentrantLock使用场景"></a>ReentrantLock使用场景</h1><p>ReentrantLock提供比内置锁更灵活的加锁方式，在JCU包中有较多应用。随着<code>synchronized</code>的性能优化，在简单加锁情况下，还是优选<code>synchronized</code>关键字，其使用简单且不需要显示释放，使用出错的几率较低。如果需要灵活的加锁策略（如上文有界缓存示例类）或需要超时机制等可以考虑使用重入锁，当需要尤其注意需要释放锁，推荐在<code>finally</code>代码块中释放锁，保证正常异常情况都能成功释放。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文在代码层面详细分析了重入锁主要函数实现，<code>ReentrantLock</code>实现了较为灵活的重入锁，对比内置<code>synchronized</code>关键字，不仅提供常规的加锁解锁操作，也提供了非阻塞获取锁及超时时间内获取锁的方法，并且通过<code>Conditon</code>对象提供灵活的线程间通信方式。但其使用比<code>synchronized</code>关键字复杂，且不能自动释放，且随着<code>synchronized</code>关键字性能的提升，故在只需要简单加锁时仍推荐使用<code>synchronized</code>关键字，在需要灵活的加锁策略时考虑使用<code>ReentrantLock</code></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
            <a href="/tags/重入锁/" rel="tag"># 重入锁</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/07/深入AQS/" rel="next" title="深入AQS">
                <i class="fa fa-chevron-left"></i> 深入AQS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjU2OC85MTI5"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/favicon.ico"
                alt="BlueRhino" />
            
              <p class="site-author-name" itemprop="name">BlueRhino</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/bluerhino" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://bluerhino.github.io" title="红杏" target="_blank">红杏</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x6982;&#x8FF0;" class="headerlink" title="&#x6982;&#x8FF0;"></a>&#x6982;&#x8FF0;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是重入？"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x4EC0;&#x4E48;&#x662F;&#x91CD;&#x5165;&#xFF1F;" class="headerlink" title="&#x4EC0;&#x4E48;&#x662F;&#x91CD;&#x5165;&#xFF1F;"></a>&#x4EC0;&#x4E48;&#x662F;&#x91CD;&#x5165;&#xFF1F;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#具体示例"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#&#x5177;&#x4F53;&#x793A;&#x4F8B;" class="headerlink" title="&#x5177;&#x4F53;&#x793A;&#x4F8B;"></a>&#x5177;&#x4F53;&#x793A;&#x4F8B;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单非重入锁"><span class="nav-number">2.2.</span> <span class="nav-text"><a href="#&#x7B80;&#x5355;&#x975E;&#x91CD;&#x5165;&#x9501;" class="headerlink" title="&#x7B80;&#x5355;&#x975E;&#x91CD;&#x5165;&#x9501;"></a>&#x7B80;&#x5355;&#x975E;&#x91CD;&#x5165;&#x9501;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单重入锁"><span class="nav-number">2.3.</span> <span class="nav-text"><a href="#&#x7B80;&#x5355;&#x91CD;&#x5165;&#x9501;" class="headerlink" title="&#x7B80;&#x5355;&#x91CD;&#x5165;&#x9501;"></a>&#x7B80;&#x5355;&#x91CD;&#x5165;&#x9501;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock的实现分析"><span class="nav-number">3.</span> <span class="nav-text"><a href="#ReentrantLock&#x7684;&#x5B9E;&#x73B0;&#x5206;&#x6790;" class="headerlink" title="ReentrantLock&#x7684;&#x5B9E;&#x73B0;&#x5206;&#x6790;"></a>ReentrantLock&#x7684;&#x5B9E;&#x73B0;&#x5206;&#x6790;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总览"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#&#x603B;&#x89C8;" class="headerlink" title="&#x603B;&#x89C8;"></a>&#x603B;&#x89C8;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重要函数"><span class="nav-number">3.2.</span> <span class="nav-text"><a href="#&#x91CD;&#x8981;&#x51FD;&#x6570;" class="headerlink" title="&#x91CD;&#x8981;&#x51FD;&#x6570;"></a>&#x91CD;&#x8981;&#x51FD;&#x6570;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">3.2.1.</span> <span class="nav-text"><a href="#&#x6784;&#x9020;&#x51FD;&#x6570;" class="headerlink" title="&#x6784;&#x9020;&#x51FD;&#x6570;"></a>&#x6784;&#x9020;&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lock函数"><span class="nav-number">3.2.2.</span> <span class="nav-text"><a href="#lock&#x51FD;&#x6570;" class="headerlink" title="lock&#x51FD;&#x6570;"></a>lock&#x51FD;&#x6570;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NonfairSync中的lock"><span class="nav-number">3.2.2.1.</span> <span class="nav-text"><a href="#NonfairSync&#x4E2D;&#x7684;lock" class="headerlink" title="NonfairSync&#x4E2D;&#x7684;lock"></a><code>NonfairSync</code>&#x4E2D;&#x7684;<code>lock</code></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairSync中的lock"><span class="nav-number">3.2.2.2.</span> <span class="nav-text"><a href="#FairSync&#x4E2D;&#x7684;lock" class="headerlink" title="FairSync&#x4E2D;&#x7684;lock"></a><code>FairSync</code>&#x4E2D;&#x7684;<code>lock</code></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lockInterruptibly函数"><span class="nav-number">3.2.3.</span> <span class="nav-text"><a href="#lockInterruptibly&#x51FD;&#x6570;" class="headerlink" title="lockInterruptibly&#x51FD;&#x6570;"></a>lockInterruptibly&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryLock函数"><span class="nav-number">3.2.4.</span> <span class="nav-text"><a href="#tryLock&#x51FD;&#x6570;" class="headerlink" title="tryLock&#x51FD;&#x6570;"></a>tryLock&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryLock-long-timeout-TimeUnit-unit-函数"><span class="nav-number">3.2.5.</span> <span class="nav-text"><a href="#tryLock-long-timeout-TimeUnit-unit-&#x51FD;&#x6570;" class="headerlink" title="tryLock(long timeout, TimeUnit unit)&#x51FD;&#x6570;"></a>tryLock(long timeout, TimeUnit unit)&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unlock函数"><span class="nav-number">3.2.6.</span> <span class="nav-text"><a href="#unlock&#x51FD;&#x6570;" class="headerlink" title="unlock&#x51FD;&#x6570;"></a>unlock&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newCondition函数"><span class="nav-number">3.2.7.</span> <span class="nav-text"><a href="#newCondition&#x51FD;&#x6570;" class="headerlink" title="newCondition&#x51FD;&#x6570;"></a>newCondition&#x51FD;&#x6570;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition对象介绍"><span class="nav-number">3.3.</span> <span class="nav-text"><a href="#Condition&#x5BF9;&#x8C61;&#x4ECB;&#x7ECD;" class="headerlink" title="Condition&#x5BF9;&#x8C61;&#x4ECB;&#x7ECD;"></a>Condition&#x5BF9;&#x8C61;&#x4ECB;&#x7ECD;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition对象实现"><span class="nav-number">3.3.1.</span> <span class="nav-text"><a href="#Condition&#x5BF9;&#x8C61;&#x5B9E;&#x73B0;" class="headerlink" title="Condition&#x5BF9;&#x8C61;&#x5B9E;&#x73B0;"></a>Condition&#x5BF9;&#x8C61;&#x5B9E;&#x73B0;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#await函数实现"><span class="nav-number">3.3.1.1.</span> <span class="nav-text"><a href="#await&#x51FD;&#x6570;&#x5B9E;&#x73B0;" class="headerlink" title="await&#x51FD;&#x6570;&#x5B9E;&#x73B0;"></a>await&#x51FD;&#x6570;&#x5B9E;&#x73B0;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#signal函数实现"><span class="nav-number">3.3.1.2.</span> <span class="nav-text"><a href="#signal&#x51FD;&#x6570;&#x5B9E;&#x73B0;" class="headerlink" title="signal&#x51FD;&#x6570;&#x5B9E;&#x73B0;"></a>signal&#x51FD;&#x6570;&#x5B9E;&#x73B0;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对比Object的wait及notify函数"><span class="nav-number">3.3.1.3.</span> <span class="nav-text"><a href="#&#x5BF9;&#x6BD4;Object&#x7684;wait&#x53CA;notify&#x51FD;&#x6570;" class="headerlink" title="&#x5BF9;&#x6BD4;Object&#x7684;wait&#x53CA;notify&#x51FD;&#x6570;"></a>&#x5BF9;&#x6BD4;Object&#x7684;wait&#x53CA;notify&#x51FD;&#x6570;</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock性能分析"><span class="nav-number">4.</span> <span class="nav-text"><a href="#ReentrantLock&#x6027;&#x80FD;&#x5206;&#x6790;" class="headerlink" title="ReentrantLock&#x6027;&#x80FD;&#x5206;&#x6790;"></a>ReentrantLock&#x6027;&#x80FD;&#x5206;&#x6790;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock使用场景"><span class="nav-number">5.</span> <span class="nav-text"><a href="#ReentrantLock&#x4F7F;&#x7528;&#x573A;&#x666F;" class="headerlink" title="ReentrantLock&#x4F7F;&#x7528;&#x573A;&#x666F;"></a>ReentrantLock&#x4F7F;&#x7528;&#x573A;&#x666F;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text"><a href="#&#x603B;&#x7ED3;" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BlueRhino</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.6</div>



  <div class="footer-custom"><div>京ICP备18009292号</div><div style="width:300px;margin:0 auto;"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802025491" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="http://p2amq694a.bkt.clouddn.com/%E5%A4%87%E6%A1%88/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">京公网安备 11010802025491号</p></a> </div></div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.6"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.6"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("SGljHq6ulYIA95YgGVzDPfMK-gzGzoHsz", "u7I1ArXHev94oiflA9cDPvh2");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  

  

  

  
  

  

  

  

  

</body>
</html>

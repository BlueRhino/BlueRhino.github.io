{"meta":{"title":"闲情记趣","subtitle":"Not a porter but a programmer","description":"My space","author":"BlueRhino","url":"http://bluerhino.github.io"},"pages":[{"title":"关于","date":"2017-12-17T10:58:02.000Z","updated":"2017-12-20T13:15:38.000Z","comments":false,"path":"about/index.html","permalink":"http://bluerhino.github.io/about/index.html","excerpt":"","text":"今天的风儿甚是喧嚣啊风中似有略略欲泣不祥的东西跟随风的足迹飘到了镇子里快走吧，在风停止之前然而猴王早已看穿了一切那边的薯片半价啊！"},{"title":"categories","date":"2017-12-17T10:52:25.000Z","updated":"2017-12-17T11:59:34.000Z","comments":false,"path":"categories/index.html","permalink":"http://bluerhino.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-12-17T11:59:01.000Z","updated":"2017-12-17T11:59:29.000Z","comments":false,"path":"tags/index.html","permalink":"http://bluerhino.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA栈溢出","slug":"JAVA栈溢出","date":"2018-01-14T12:01:21.000Z","updated":"2018-01-14T12:01:21.000Z","comments":true,"path":"2018/01/14/JAVA栈溢出/","link":"","permalink":"http://bluerhino.github.io/2018/01/14/JAVA栈溢出/","excerpt":"Java栈溢出小记今天偶然有人问起如何在编写Java代码使其在运行时抛出栈溢出异常，看似简单的问题涉及到了Java虚拟机的知识，特记录于此文。","text":"Java栈溢出小记今天偶然有人问起如何在编写Java代码使其在运行时抛出栈溢出异常，看似简单的问题涉及到了Java虚拟机的知识，特记录于此文。 Java虚拟机结构简介根据《Java虚拟机规范》(The Java Virtual Machine Specification)对于Java虚拟机运行时数据区域(Run-Time Data Areas)的描述，虚拟机运行时的描述，其构成图如下所示:图中，PC寄存器、Java虚拟机栈及本地方法栈为各线程私有，方法区（包括运行时常量取）及堆为线程间共享的存储空间。针对问题提出的栈溢出，有两个区域与其相关，包括Java虚拟机栈及本地方法栈。查阅《Java虚拟机规范》，针对栈溢出有如下两段描述：对于Java虚拟机栈 The following exceptional conditions are associated with Java Virtual Machine stacks: If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError. If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError. 对于本地方法栈 The following exceptional conditions are associated with native method stacks: If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a StackOverflowError. If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError. 由此可见对于Java虚拟机栈与本地方法栈都定义了相似的两种溢出： 线程请求栈上分配内存时，内存不足：此溢出一般出现在线程递归调用方法时。在线程调用方法时虚拟机创建栈帧保存方法调用信息，在方法调用完成后销毁栈帧释放存储，如果在方法调用过程中无法创建栈帧则会报出StackOverflowError异常。 动态扩展栈或线程创建时无法分配足够内存：此溢出一般出现在创建新的线程时。创建新的线程，需要在栈上为其分配存储，如果此时栈上存储不足以分配则会报出OutOfMemoryError异常。 代码实现以下代码在Mac版JDK8中实现及运行，由于HotSpot实现中没有分Java虚拟机栈及本地方法栈[1]，故以下代码只针对Java虚拟机栈。Hotspot中设置栈容量的参数为-Xss，后续实验均设置-Xss1M，使用Junit4进行测试 分配栈帧失败（StackOverflowError）代码为：12345678910111213141516public class StackOverflow &#123; public void callMyself(int depth) &#123; System.out.println(depth); callMyself(++depth); &#125;&#125;public class StackOverflowTest &#123; @Test public void callMyself() throws Exception &#123; StackOverflow overflow = new StackOverflow(); overflow.callMyself(0); &#125;&#125; 最终会抛出java.lang.StackOverflowError，且最终能够达到的栈深度主要与栈内存最大大小与栈帧中局部变量占用的空间有关。使用如下代码最大深度会明显变小12345678public class StackOverflow &#123; public void callMyself(int depth) &#123; int a,b,c,d,e,f,g,h,i,j,k; System.out.println(depth+\"|\"); callMyself(++depth); &#125;&#125; 为线程分配栈上内存失败（OutOfMemoryError）代码为：1234567891011121314151617181920public class OutOfMemory &#123; public void createThread() &#123; while (true) &#123; Thread t = new Thread(() -&gt; &#123; while (true) &#123; System.out.println(System.currentTimeMillis()); &#125; &#125;); t.start(); &#125; &#125;&#125;public class OutOfMemoryTest &#123; @Test public void createThread() throws Exception &#123; OutOfMemory outOfMemory = new OutOfMemory(); outOfMemory.createThread(); &#125;&#125; 最终会抛出OutOfMemoryError。 参考文献[1] 周志明.深入理解Java虚拟机[M].北京:机械工业出版社,53","categories":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://bluerhino.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"http://bluerhino.github.io/tags/JVM/"},{"name":"JAVA虚拟机","slug":"JAVA虚拟机","permalink":"http://bluerhino.github.io/tags/JAVA虚拟机/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://bluerhino.github.io/tags/栈溢出/"}]},{"title":"感知机对偶形式学习","slug":"感知机对偶形式学习","date":"2017-12-21T14:01:56.000Z","updated":"2017-12-26T15:24:28.000Z","comments":true,"path":"2017/12/21/感知机对偶形式学习/","link":"","permalink":"http://bluerhino.github.io/2017/12/21/感知机对偶形式学习/","excerpt":"总结感知机及其对偶形式","text":"总结感知机及其对偶形式 问题背景实际应用中常出现二元分类问题，如引用台湾大学机器学习基石课程[1]的信用卡案例：如有用户申请信用卡，其个人信息如下： 特征 数据 年龄 23 性别 女 年收入 1，000，000 居住年限 1 工作年限 0.5 负债 200，000 银行具有原来的信用卡申请记录（包括申请用户信息及审批结果），如何根据原来的记录判断当前申请是否能够批准就是一个典型的二分问题。输入数据为个人信息，训练数据为历史申请及审批记录，输出数据为是否同意申请。假设银行根据申请用户的各项信息（特征）为用户打分，并且设定一个阈值，在用户得分超过该阈值则同意信用卡申请，否则拒绝申请。故假设用户具m个特征为$$x=({x_1,x_2,\\cdots,x_m})$$得分阈值为$d$。每个特征对于最终的用户得分有不同的重要程度，所以为每一个特征增加入不同的权值$w=({w_1,w_2,\\cdots,w_m})$，用户最终得分为$$w_1x_1+w_2x_2+ \\cdots +w_mx_m=\\sum_{i=1}^{m}w_ix_i$$最后只需要比较 $\\sum_{i=1}^{m}w_ix_i$与阈值$d$的大小就可以得出结果。观察上文公式，如何确定每一个信息的权值$w$及同意申请的阈值$d$就是解决问题的关键，由于具有历史数据，使用历史数据确定参数的想法就水到渠成。 问题抽象根据上文背景问题的提出，可进行抽象，银行n笔已知的数据可以抽象为训练数据集$$T={(x_1,y_1),(x_2,y_2),\\cdots,(x_n,y_n)}$$其中$x\\in\\chi ,\\chi\\subseteq R^m$，$y\\in\\mathcal{Y}={+1,-1}$。设上文求和公式及阈值之差为函数$$h(x)=\\sum_{i=1}^{m}w_ix_i-d$$为简化公式取$b=-d$，则公式变化为：$$h(x)=\\sum_{i=1}^{m}w_ix_i+b$$改写为向量形式为:$$h(x)=w\\cdot x+b$$当$h(x)&gt;0$时，发放信用卡，否则拒绝发放信用卡使用取符号的函数$sign$，得到函数$$f(x)=sign(w\\cdot x+b)$$此函数为感知机算法需要学习得到的最终函数。 感知机介绍感知机1957年由Rosenblatt提出，是支持向量机及神经网络基础算法。感知机主要通过训练数据集学习函数：$$f(x)=sign(w\\cdot x+b)$$中的模型参数$w$及$b$，其中$x\\in\\chi ,\\chi\\subseteq R^m,w\\in R^m,b\\in R$。感知机算法要求训练集是线性可分，当训练集线性可分时可以证明感知机算法可以通过有限次的搜索找到将训练集完全区分的超平面，否则感知机算法将不会收敛[2]。 未完待续 参考文献[1] 林轩田.机器学习基石[R].台湾:台湾大学.[2] 李航.统计学习方法[M].北京:清华大学出版社,2012:26-33.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://bluerhino.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://bluerhino.github.io/tags/机器学习/"},{"name":"感知机","slug":"感知机","permalink":"http://bluerhino.github.io/tags/感知机/"},{"name":"统计学习方法","slug":"统计学习方法","permalink":"http://bluerhino.github.io/tags/统计学习方法/"},{"name":"李航","slug":"李航","permalink":"http://bluerhino.github.io/tags/李航/"}]},{"title":"java.util.concurrent.locks.Lock详解","slug":"java-util-concurrent-locks-Lock详解","date":"2017-10-23T11:39:22.000Z","updated":"2017-12-23T03:03:23.000Z","comments":true,"path":"2017/10/23/java-util-concurrent-locks-Lock详解/","link":"","permalink":"http://bluerhino.github.io/2017/10/23/java-util-concurrent-locks-Lock详解/","excerpt":"简介java.util.concurrent.locks.Lock接口（以下简称Lock）作者Doug Lea，对比使用synchronized关键字进行并发控制，Lock接口的实现类可以完成更灵活的加锁操作。本文以下会详细介绍Lock接口相关功能，并对比Lock接口及synchronized关键字在功能上（非性能对比）的异同。","text":"简介java.util.concurrent.locks.Lock接口（以下简称Lock）作者Doug Lea，对比使用synchronized关键字进行并发控制，Lock接口的实现类可以完成更灵活的加锁操作。本文以下会详细介绍Lock接口相关功能，并对比Lock接口及synchronized关键字在功能上（非性能对比）的异同。 Lock接口相关功能介绍如图所示，Lock接口定义6个方法。 lock 尝试获取锁，如当前线程无法获取锁，则当前线程进入无法调度的休眠状态，直到获取锁。 lockInterruptibly 与 lock相似，主要区别在于调用该方法后，如无法获取锁，则当前线程进入无法调度的休眠状态，直到出现以下两种情况： 获取锁； 当前线程被其他线程中断。 Lock接口及synchronized关键字对比synchronized作为Java语言的并发控制关键字，在多线程编程中十分常用，主要有三种使用方式： 修饰对象方法； 修饰静态方法； 修饰同步方法快。使用synchronized关键字可以完成对访问共享资源的代码块的显示加锁和隐式释放锁。在代码离开synchronized关键字修饰的区域后，synchronized自动释放锁定。Lock接口将加锁及解锁操作控制权都交给程序员，这增加了锁的灵活性却也增加了出现逻辑问题的可能性。总结未完待续","categories":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/tags/Java/"},{"name":"同步","slug":"同步","permalink":"http://bluerhino.github.io/tags/同步/"}]},{"title":"CopyOnWriteArrayList学习总结","slug":"CopyOnWriteArrayList学习总结","date":"2017-10-17T12:28:00.000Z","updated":"2017-12-23T03:09:30.000Z","comments":true,"path":"2017/10/17/CopyOnWriteArrayList学习总结/","link":"","permalink":"http://bluerhino.github.io/2017/10/17/CopyOnWriteArrayList学习总结/","excerpt":"简介CopyOnWriteArrayList类位于java.util.concurrent包，JDK1.5引入，作者为Doug Lea。CopyOnWriteArrayList是一个线程安全的List，使用“写时复制”的思想在进行所有写入操作（增加、删除等）是都会进行内部存储元素数组的复制。","text":"简介CopyOnWriteArrayList类位于java.util.concurrent包，JDK1.5引入，作者为Doug Lea。CopyOnWriteArrayList是一个线程安全的List，使用“写时复制”的思想在进行所有写入操作（增加、删除等）是都会进行内部存储元素数组的复制。 代码分析写时过程由于采用写时复制的策略，其主要作用过程在于对存储数据进行修改时。以add函数为例。一下为JDK8中实现源码：1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 进入函数首先获取ReentrantLock重入锁； 获取当前对象中实际存储数据的Objecte数组； 复制当前数组并且将数组长度扩展1； 将新数据插入当前数组的最后一位； 将指向原数组的变量置为指向新数组，释放锁，完成工作。 对比ArrayList增加元素代码：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 通过查看代码可知，ArrayList在写入时是没有加锁的，所以多线程情况下使用并不安全，需要程序员手动进行并发控制。引用源码中说明为： Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be “wrapped” using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list:List list = Collections.synchronizedList(new ArrayList(…)); 验证ArrayList线程不安全可使用以下代码12345678910111213141516171819202122232425262728293031323334public class Main &#123; static class AddThread implements Runnable &#123; private List&lt;String&gt; list; private CountDownLatch countDownLatch; public AddThread(List&lt;String&gt; list, CountDownLatch countDownLatch) &#123; this.list = list; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); for(int i=0;i&lt;500;i++)&#123; list.add(\"1\"); &#125; &#125; &#125; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(1); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 200; i++) &#123; new Thread(new AddThread(list, countDownLatch)).start(); &#125; countDownLatch.countDown(); &#125;&#125; 运行过程中大概率会出现Java.lang.ArrayIndexOutOfBoundsException错误 优点使用CopyOnWriteArrayList可以不用进行手动同步控制，并且由于使用了读写分离的措施，在进行写入时可以同时进行数据的读取，并且数据读取过程中不需要加锁。 缺点根据其实现代码，CopyOnWriteArrayList的缺点同样明显。首先、其每次写入都需要进行数组的复制，所以对于写入操作非常消耗系统资源，尤其是内存资源，这种情况在处理存储较多数据的List时尤其明显。对于gc也造成了较大压力。其次，由于其在读取时不需要获取锁，造成如写入数据同时进行读取可能造成读取到的数据为旧数组中的数据，可能造成数据的不一致。 使用场景由此可见，CopyOnWriteArrayList比较适合用在大量读取小量写入的场景，并且要求系统对于数据的不一致宽容度较高。针对写时复制的策略，在必须要进行写入时尽量将多次写入合并为一次写入，减少数组复制次数。","categories":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/tags/Java/"},{"name":"同步","slug":"同步","permalink":"http://bluerhino.github.io/tags/同步/"}]},{"title":"Spring @Autowired+@Qualifier与@Resource的区别","slug":"Spring @Autowired+@Qualifier与@Resource的区别","date":"2016-06-02T13:37:17.000Z","updated":"2017-12-23T03:04:58.000Z","comments":true,"path":"2016/06/02/Spring @Autowired+@Qualifier与@Resource的区别/","link":"","permalink":"http://bluerhino.github.io/2016/06/02/Spring @Autowired+@Qualifier与@Resource的区别/","excerpt":"最近由于希望使用Spring在XML文件中定义List的bean，并使用@Autowired进行注入到对象中使用，遇到到一些坑，记录一下作为备忘。","text":"最近由于希望使用Spring在XML文件中定义List的bean，并使用@Autowired进行注入到对象中使用，遇到到一些坑，记录一下作为备忘。 @Autowired@Autowired是Spring定义的注解，是根据类型进行自动装配的。如果当spring上下文中存在不止一个存在一个需要装配类型的bean时，就会抛出BeanCreationException异常;这时我们可以使用@Qualifier配合@Autowired来解决问题。 @Resource@Resource是JSR-250规定的注解，主要有两种类型的属性type及name，所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略 。@Resource装配顺序: 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； 使用区别使用Spring注入List的时候在XML中定义: 1234&lt;util:list id=\"myList\"&gt; &lt;value&gt;10.1.200.104&lt;/value&gt; &lt;value&gt;10.1.200.205&lt;/value&gt;&lt;/util:list&gt; 之后使用注解注入，代码1为： 12345@Componentpublic class App &#123; @Autowired List list;&#125; 注入失败。修改，代码2为： 12345@Componentpublic class App &#123; @Autowired ArrayList&lt;String&gt; strings;&#125; 注入仍然失败。修改，代码3为： 123456@Componentpublic class App &#123; @Autowired @Qualifier('myList') ArrayList&lt;String&gt; strings;&#125; 仍然失败。主要原因在于，使用Autowired注入，Spring默认使用按类型方式注入，而对于List集合类型Spring会读取其中的泛型类型进行注入，上面代码2的含义为注入当前bean中类型为String的对象，代码3的含义为注入当前bean中类型为String且qualifier是myList的对象。这两种含义都不能完成正确的注入。 正确使用使用@Resource注入,引用stackoverflow上的解答使用正确方式为： 1234567@Componentpublic class App &#123; @Resource(name = \"myList\") ArrayList&lt;Object&gt; list;&#125; 或者 1234567@Componentpublic class App &#123; @Resource(name = \"myList\") List&lt;Object&gt; list;&#125; 因为Resource设置了name属性，Spring直接寻找id为myList的对象进行注入，可以注入成功。","categories":[{"name":"Java","slug":"Java","permalink":"http://bluerhino.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://bluerhino.github.io/tags/Spring/"},{"name":"@Autowired","slug":"Autowired","permalink":"http://bluerhino.github.io/tags/Autowired/"},{"name":"@Qualifier","slug":"Qualifier","permalink":"http://bluerhino.github.io/tags/Qualifier/"},{"name":"@Resource List","slug":"Resource-List","permalink":"http://bluerhino.github.io/tags/Resource-List/"}]}]}
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[细谈重入锁ReentrantLock]]></title>
      <url>/2018/04/26/%E7%BB%86%E8%B0%88%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在<a href="/2017/10/23/java-util-concurrent-locks-Lock详解/" title="java.util.concurrent.locks.Lock详解">java.util.concurrent.locks.Lock详解</a>一文中简单的描述了JDK中JUC包对于Lock接口的定义，并且简单的对比了Lock接口及Java关键字synchronized的异同。本文主要研究Lock接口的常用实现ReentrantLock，本文主要分为以下几部分：</p>
<ol>
<li>什么是重入？</li>
<li>ReentrantLock的实现分析；</li>
<li>Condition对象介绍；</li>
<li>ReentrantLock性能分析；</li>
<li>ReentrantLock使用场景；</li>
<li>总结。<a id="more"></a>
</li>
</ol>
<h1 id="什么是重入？"><a href="#什么是重入？" class="headerlink" title="什么是重入？"></a>什么是重入？</h1><p>ReentrantLock通过类名称可顾名思义，由Reentrant及Lock两部分组成。Lock略去不谈，观察Reentrant单词可以简单将其拆为前缀re及主体entrant，即re：再，entrant：进入。<br>显而易见重入就是再次进入的意思，在并发编程中具体指某线程已经获取了一个锁后，再次请求这个锁时可以获得该锁而不会阻塞。</p>
<h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>在某线程递归调用某函数时较容易观察重入锁与非重入锁区别，如以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//将i重置</span></span><br><span class="line">          i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        reentrantLockTest.callBack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>callBack函数使用synchronized关键字进行同步控制，synchronized关键字可以确保同时只有一个线程可进入临界区，并且由于synchronized支持重入，故上面的代码可以正常运行（synchronized关键字实现原理以后再做补充）。</p>
<h2 id="简单非重入锁"><a href="#简单非重入锁" class="headerlink" title="简单非重入锁"></a>简单非重入锁</h2><p>现为Lock接口编写一个简单实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueRhinoLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlueRhinoLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他接口函数略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>简单起见，该锁基于BlockingQueue将capacity取值为1，实现了一个不可重入的排它锁。如以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    BlueRhinoLock blueRhinoLock = <span class="keyword">new</span> BlueRhinoLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blueRhinoLock.lock();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blueRhinoLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; reentrantLockTest.callBack()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此段代码不使用synchronized关键字而使用BlueRhinoLock进行同步控制，在任一线程运行到<code>blueRhinoLock.lock();</code><br>语句后获取锁，则所有其他线程需要在此等待。但由于本段代码中存在回调，同一线程会在回调callBack时再次运行到<code>blueRhinoLock.lock();</code><br>代码行时则由于无法获取锁进入等待，则形成由于锁不支持重入而形成死锁。运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line"><span class="comment">//无法继续打印</span></span><br></pre></td></tr></table></figure></p>
<h2 id="简单重入锁"><a href="#简单重入锁" class="headerlink" title="简单重入锁"></a>简单重入锁</h2><p>为了解决以上死锁问题，需要对以上的简单锁进行改进使其支持重入。主要需要完成对于同一线程请求锁时，若当前线程已经拥有当前锁且没有释放的情况下，直接继续执行，根据以上思路配合使用ThreadLocall可以将代码修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueRhinoReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlueRhinoReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.blockingQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(threadLocal.get() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object o = blockingQueue.take();</span><br><span class="line">                threadLocal.set(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object o = threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span>(o == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意以上为测试代码，没有充分考虑安全性问题</strong></p>
<p>以上代码使用ThreadLocal记录当前线程是否已经获取锁，解决了重入问题。调用代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    BlueRhinoReentrantLock blueRhinoLock = <span class="keyword">new</span> BlueRhinoReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blueRhinoLock.lock();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            callBack();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blueRhinoLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; reentrantLockTest.callBack()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ReentrantLock的实现分析"><a href="#ReentrantLock的实现分析" class="headerlink" title="ReentrantLock的实现分析"></a>ReentrantLock的实现分析</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>以上代码简单演示了重入锁与非重入锁的区别，但是代码实现非常粗糙，本节主要深入到JDK8中ReentrantLock类的实现，学习生产级别的代码如何实现重入锁。<br>JDK8中ReentrantLock代码包括注释为763行，作者为大神<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>。其UML图为：<img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/ReentrantLockUML.png" alt=""><br>通过UML可以看出与ReentrantLock与其相关类（接口）之间的重要关系：</p>
<ol>
<li>ReentrantLock实现了Lock接口（应该说是废话）；</li>
<li>抽象类Sync是ReentrantLock重要组成部分；</li>
<li>FairSync及NonFairSync均继承于Sync；</li>
<li>Sync继承抽象类了AbstractQueuedSynchronizer；</li>
<li>AbstractQueuedSynchronizer继承了抽象类AbstractOwnableSynchronizer。</li>
</ol>
<p>下文从一些重要的函数入手开始研究其实现。</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ReentrantLock只有两个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数均比较简单，都创建了一个Sync类型的实例变量，由于Sync是抽象类，实际创建的为其子类，默认为NonfairSync，在带boolean参数的构造函数中可以使用参数值指定创建NonfairSync或FairSync对象。源码中对于Sync的介绍为：</p>
<blockquote>
<p>Base of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock.</p>
</blockquote>
<p>重点在于使用AQS（AbstractQueuedSynchronizer）记录锁的获取数量，由此可见AbstractQueuedSynchronizer为ReentrantLock实现提供了重要支持。在前面的文章<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>介绍了AQS相关技术。</p>
<h3 id="lock函数"><a href="#lock函数" class="headerlink" title="lock函数"></a>lock函数</h3><p>lock函数为Lock接口的核心函数之一，在Lock接口中对于该函数的注释为:</p>
<blockquote>
<p>Acquires the lock.<br>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
</blockquote>
<p>在ReentrantLock的实现中对于Lock函数也有注释：</p>
<blockquote>
<p>Acquires the lock.<br>Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one.<br>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.<br>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</p>
</blockquote>
<p>对比两段注释可见，都表明该函数主要功能为“获取锁”。<br>在Lock接口中仅仅规定如果当前线程无法获取锁则进入无法调度的休眠状态直到获得锁。<br>在ReentrantLock实现时细化了其实现细节，说明在当前线程获得锁后，将其锁计数器置为1，以后持有该锁的线程再次申请锁则将计数器加1并且立即返回，如当前线程无法获取锁则进入无法调度的休眠状态直道获取锁，并且在获取锁的同时将锁计数器置为1。现在具体看实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可见直接调用了<code>sync</code>的<code>lock</code>函数，再进入<code>lock</code>函数进行研究。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sync</code>的<code>lock</code>函数是一个抽象函数，在两个子类<code>NonfairSync</code>、<code>FairSync</code>中进行了不同实现，上一节构造函数中已经看见过这两个类了，分别代表非公平算法实现的同步器及公平算法实现的同步器，无参数构造函数默认创建的是非公平的同步器。  </p>
<h4 id="NonfairSync中的lock"><a href="#NonfairSync中的lock" class="headerlink" title="NonfairSync中的lock"></a><code>NonfairSync</code>中的<code>lock</code></h4><p>先考察<code>NonfairSync</code>中的<code>lock</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入函数首先使用<code>compareAndSetState</code>函数进行设置，该函数实际是从<code>AbstractQueuedSynchronizer</code>类继承而来，其功能为使用CAS操作<strong>原子</strong>的设置对象中一个名为<code>state</code>的<code>int</code>型变量。<br>如果实际值与期望值相等均为0，说明当前锁没有被持有，则直接将<code>state</code>设置为1，继续调用<code>setExclusiveOwnerThread</code>函数将当前锁的所有者设置为当前线程。<br>如果实际值与期望值0不相等则说明当前锁已经被别的线程获取，需要使用<code>acquire</code>函数进行锁的获取，该函数仍然是从<code>AbstractQueuedSynchronizer</code>类继承而来其过程如下：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/AbstractQueuedSynchronizer_acquire.png" alt=""><br>根据流程图继续进行分析，进入<code>acquire</code>函数首先调用<code>tryAcquire</code>再次尝试获取锁，这是因为在线程从使用<code>compareAndSetState</code>设置<code>state</code>失败到当前时刻，原来占用锁的的线程可能已经释放了锁，如果这次尝试成功可以较大的减少将线程加入等待队列的性能消耗。根据前文<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>的介绍，<code>tryAcquire</code>函数是<code>AQS</code>类的成员函数，使用继承<code>AQS</code>类的方式实现同步器时需要在子类覆盖<code>tryAcquire</code>方法。在<code>ReentrantLock</code>中对于<code>tryAcquire</code>调用会根据当前锁是否公平锁，而最终调用<code>NonfairSync</code>或<code>FairSync</code>对象的<code>tryAcquire</code>方法。<br>由于本处分析<code>NonfairSync</code>的<code>lock</code>函数，则继续查看<code>NonfairSync</code>的<code>tryAcquire</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>其最终调用<code>nonfairTryAcquire</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要完成如下逻辑：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/%E9%87%8D%E5%85%A5%E9%94%81tryAcquire.png" alt=""></p>
<ol>
<li>获取当前线程对象及当前锁的状态值；</li>
<li>如果当前锁的状态值为0，则说明当前没有线程获取锁，使用CAS方式设置锁的状态为acquires（根据上文参数，此处为1）；如果不为0说明已有线程获取了锁，直接跳转到第5步；</li>
<li>如果设置成功，说明获取锁成功，则直接将当前锁的排他所有者线程设置为当前线程（由于第二步CAS设置只可能有一个线程成功，此处代码不需要作临界区保护）；</li>
<li>如果设置不成功，说明同一时刻有其他线程调用<code>compareAndSetState</code>，并且获得成功，则当前线程竞争锁失败直接返回false；</li>
<li>当前状态值不为0，需要继续判断以获取锁的线程是不是当前线程：  <ol>
<li>如果是，说明当前是同一线程重入的获取锁，则将当前锁状态加acquires（根据上文参数，此处为1），之后锁状态如果溢出，抛出异常，否则将锁的状态设置为新的值，返回true；</li>
<li>如果不是，尝试获取锁失败，直接返回false</li>
</ol>
</li>
</ol>
<p>以上第5.1步逻辑是实现重入的关键代码。<br>完成<code>tryAcquire</code>调用后，如果获取锁失败，则将当前线程封装为等待节点加入等待队列中。后续详细操作主要由<code>AQS</code>完成，可参考<strong><a href="/2018/04/07/深入AQS/" title="深入AQS">深入AQS</a></strong>。</p>
<h4 id="FairSync中的lock"><a href="#FairSync中的lock" class="headerlink" title="FairSync中的lock"></a><code>FairSync</code>中的<code>lock</code></h4><p>继续研究<code>FairSync</code>中的<code>lock</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>为方便比较将<code>NonfairSync</code>的<code>lock</code>拷贝下来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比代码可见公平锁实现较非公平锁简单，其直接调用<code>acquire</code>函数，<strong>第一次放弃插队的机会</strong>。而<code>acquire</code>函数如上文分析，最开始会调用<code>FairSync</code>类实现的<code>tryAcquire</code>函数，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比非公平锁代码，其实现最大逻辑区别在于第五行，公平锁实现时，在当前锁没有被其他线程获取时，会判断当前等待队列是否有等待锁的线程，如果没有才会获取锁，否则直接返回失败，在此处<strong>第二次放弃插队机会</strong>，由此保证线程获取锁的顺序一定与申请锁的等待时间相同。</p>
<h3 id="lockInterruptibly函数"><a href="#lockInterruptibly函数" class="headerlink" title="lockInterruptibly函数"></a>lockInterruptibly函数</h3><p><code>lockInterruptibly</code>函数是前文<code>lock</code>函数的可中断版本，查看源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数通过调用<code>AQS</code>类的<code>acquireInterruptibly</code>函数实现，继续查看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数实现逻辑与<code>lock</code>函数调用的<code>AQS</code>类的<code>lock</code>函数基本相同，主要增加了对线程中断的判断。进入函数首先判断当前线程是否已经中断，中断后则直接抛出中断异常，停止获取锁。如果没有被中断，则调用<code>tryAcquire</code>尝试获取锁，如果获取锁失败则进入<code>doAcquireInterruptibly</code>函数，该函数代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>对比<code>lock</code>函数调用的<code>acquireQueued</code>函数，主要区别在于第16行，如果在阻塞过程中被中断直接抛出中断异常到上层函数，并且取消当前等待节点。</p>
<h3 id="tryLock函数"><a href="#tryLock函数" class="headerlink" title="tryLock函数"></a>tryLock函数</h3><p><code>tryLock</code>函数尝试获取锁，与<code>lock</code>函数不同在于，该函数不阻塞，如果函数锁成功则返回true，否则直接返回false。</p>
<h3 id="tryLock-long-timeout-TimeUnit-unit-函数"><a href="#tryLock-long-timeout-TimeUnit-unit-函数" class="headerlink" title="tryLock(long timeout, TimeUnit unit)函数"></a>tryLock(long timeout, TimeUnit unit)函数</h3><p>该函数与<code>lock</code>函数逻辑相似，主要区别在于调用<code>LockSupport</code>工具类时使用<code>parkNanos</code>函数，指定等待时间。该函数在获取到锁或者达到过期时间时返回，获取锁则返回true，否则返回false。</p>
<h3 id="unlock函数"><a href="#unlock函数" class="headerlink" title="unlock函数"></a>unlock函数</h3><p>unlock函数用于释放锁，其调用syn.release函数，代码在<code>AQS</code>中实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其逻辑为调用<code>tryRelease</code>函数释放锁，在释放成功后唤醒当前头结点的后续等待节点。<code>tryRelease</code>在<code>AQS</code>中没有具体实现，在<code>ReentrantLock</code>类的内部工具类<code>Syn</code>中实现，代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑为：</p>
<ol>
<li>获取当前加锁状态，并将其减少releases(此处为1);</li>
<li>判断当前线程是否是获取锁的线程，如果当前线程没有获取锁则直接抛出异常;</li>
<li>若没有异常则需判断当前的加锁状态是否为0，此步与每次重入加锁状态加1对应，如果当前加锁状态已经为0，表示当前线程已经释放锁，则重新设置锁的持有线程为空，返回<code>true</code>，上文<code>release</code>函数不唤醒后续节点;</li>
<li>若加锁状态不为0，则更新加锁状态，返回<code>false</code>，上文<code>release</code>函数不唤醒后续节点。</li>
</ol>
<h3 id="newCondition函数"><a href="#newCondition函数" class="headerlink" title="newCondition函数"></a>newCondition函数</h3><p>该函数用于返回一个<code>Condition</code>接口实例，该类在<code>AQS</code>中有相关实现<code>ConditionObject</code>，由于<code>ConditionObject</code>为<code>AQS</code>非静态内部类，故通过调用<code>newCondition</code>函数创建的<code>Condition</code>接口实例会与当前的<code>AQS</code>对象自动关联起来（此处可参考非静态内部类特点）。对于<code>Condition</code>接口下一节再详细介绍。</p>
<h2 id="Condition对象介绍"><a href="#Condition对象介绍" class="headerlink" title="Condition对象介绍"></a>Condition对象介绍</h2><p><code>Condition</code>接口主要用于多线程加锁环境下，不同线程之间的协作。提供的核心方法为<code>await</code>及<code>signal</code>，语义为等待和通知。参考使用代码为：<br><span id="BoundedBuffer"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">     <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">     <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></span></p>
<p>以上代码引用自JDK8的Condition注释，实现了一个简单的有界缓存。主要包括存和取两个函数，由于可能使用与多线程环境，类中定义了一个重入锁进行对象属性的包括，保证同一时刻最多仅有一个线程可对有界缓存进行操作。但在缓存使用过程中，可能出现存入对象时有界队列已满，或取对象时队列还是空这两种情况。<br>当缓存在插入对象时，如队列已满则阻塞等待缓存有空间后继续插入；在读取对象时，如缓存为空则阻塞等待直到缓存有新的元素插入。<br>为实现以上功能，该段代码使用了使用<code>lock.newCondition()</code>创建notFull，notEmpty两个<code>Condition</code>对象，分别表示当前缓存非满和非空，在线程满时调用<code>notFull.await()</code>阻塞等待，直到缓存有空间后调用<code>notFull.signal()</code>唤醒等待线程，<code>notEmpty</code>用法类似。<br>那<code>Condition</code>对象是如何完成以上功能？与<code>Object</code>提供的<code>wait</code>及<code>notify</code>函数又有何区别？  </p>
<h3 id="Condition对象实现"><a href="#Condition对象实现" class="headerlink" title="Condition对象实现"></a>Condition对象实现</h3><p>通过以上示例可以学习到Condition接口的两个主要函数的用法，现在通过观察其代码实现学习具体实现逻辑。</p>
<h4 id="await函数实现"><a href="#await函数实现" class="headerlink" title="await函数实现"></a>await函数实现</h4><p>本处查看<code>AQS</code>类中<code>Condition</code>接口的实现类<code>ConditionObject</code>中await函数的实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码发现该函数主要逻辑为：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/Condition-await.png" alt=""><br>其中释放锁时相当于将当前节点从<code>AQS</code>的头节点移除。<br>使用<code>await</code>需要注意需要在当前线程获取锁后再调用，否则在释放锁时会抛出<code>IllegalMonitorStateException</code>异常，且在增加等待队列时会调用<code>unlinkCancelledWaiters</code>函数，该函数并不是线程安全的，这也要求调用该函数时需要首先获取锁。<br>另外在中断方面可以发现如果在<code>Condition</code>对象的等待队列中被中断，当前等待节点会从<code>Condition</code>对象的等待队列中被移除，但是仍然会将自己添加到<code>AQS</code>的等待队列中继续尝试获取锁。所以调用<code>await</code>函数后，即使等待线程被中断也不会立即抛出中断异常，仍然需要等到其获取到锁后才能根据不同中断处理模式进行中断处理。</p>
<h4 id="signal函数实现"><a href="#signal函数实现" class="headerlink" title="signal函数实现"></a>signal函数实现</h4><p>此处仍然查看<code>AQS</code>类中<code>ConditionObject</code>中<code>signal</code>的实现代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码首先调用<code>isHeldExclusively</code>函数判断当前线程是否排他的持有当前锁，如果不存在则直接抛出<code>IllegalMonitorStateException</code>异常。如果持有锁则调用<code>doSignal</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>此段代码逻辑也比较简单，首先将<code>ConditionObject</code>的等待节点的头结点设置为待转移节点的后续节点，调用<code>transferForSignal</code>方法将待转移节点附到<code>AQS</code>等待队列的队尾。这里需要注意的是<code>transferForSignal</code>函数的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数首先将节点状态从<code>Node.CONDITION</code>设置为无状态，如果当前状态不为<code>Node.CONDITION</code>则返回上层函数，继续设置下一个节点。将节点设置为无状态后将其加入<code>AQS</code>等待队列，并且判断前置节点状态，如果前置节点已经被取消，则唤醒当前节点中阻塞的线程。根据<code>Condition</code>实现可知，当前节点阻塞的线程必然在<code>await</code>函数的<code>LockSupport.park(this)</code>行阻塞，如果发现其前驱节点已经取消则直接唤醒该线程，此处需要注意唤醒此线程并不会让该线程直接获取锁，该线程仍然需要等待获取锁。<br>对于<code>Condition</code>对象的其他函数核心实现逻辑相似，不在赘述。</p>
<h4 id="对比Object的wait及notify函数"><a href="#对比Object的wait及notify函数" class="headerlink" title="对比Object的wait及notify函数"></a>对比Object的wait及notify函数</h4><p>根据上文分析<code>Condition</code>类的<code>await</code>及<code>signal</code>函数与<code>Object</code>类的<code>wait</code>及<code>notify</code>功能似乎非常类似，此处进行两种实现的对比。 </p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>所属类或接口</th>
<th>功能</th>
<th>使用条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait</td>
<td>Object</td>
<td>阻塞等待其他线程调用notify</td>
<td>需要先使用synchronized获取调用对象的锁</td>
</tr>
<tr>
<td>notify</td>
<td>Object</td>
<td>使被wait阻塞的线程进度调度</td>
<td>需要先使用synchronized获取调用对象的锁</td>
</tr>
<tr>
<td>await</td>
<td>Condition</td>
<td>阻塞等待其他线程调用signal</td>
<td>需要先获取Condition对象关联的锁对象代表的锁</td>
</tr>
<tr>
<td>signal</td>
<td>Condition</td>
<td>使被await阻塞的线程进度调度</td>
<td>需要先获取Condition对象关联的锁对象代表的锁</td>
</tr>
</tbody>
</table>
<p>直接查看发现以上两种线程间交互方式似乎没有明显不同，但在使用中<code>await</code>及<code>notify</code>方式明细较为灵活，因为一个<code>Lock</code>对象可以创建多个<code>Condition</code>对象用于说明在同一互斥资源上不同的等待条件，如上文<a href="#BoundedBuffer"><code>BoundedBuffer缓存示例代码</code></a>，如果使用<code>wait</code>配合<code>synchronized</code>进行实现，则必须同时唤醒插入及读取队列，并且根据判断，总有一个函数需要继续阻塞等待，效率及灵活性都较差。</p>
<h1 id="ReentrantLock性能分析"><a href="#ReentrantLock性能分析" class="headerlink" title="ReentrantLock性能分析"></a>ReentrantLock性能分析</h1><p>本文没有针对重入锁性能进行深入测试，参考<a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a>一书总结如下：<code>ReentrantLock</code>与内置锁<code>synchronized</code>在JAVA6之后性能差距不大。<code>ReentrantLock</code>锁的公平实现高并发性能明显低于非公平实现，针对代码分析，造成这种原因在于公平锁在高度竞争条件下几乎所有线程都会经过排队及上下文切换（即经过park函数阻塞及unpark函数唤醒），而非公平锁由于可能存在插队的情况，线程上下文切换次数明显少于公平锁，这是是的非公平锁性能更好的主要原因。</p>
<h1 id="ReentrantLock使用场景"><a href="#ReentrantLock使用场景" class="headerlink" title="ReentrantLock使用场景"></a>ReentrantLock使用场景</h1><p>ReentrantLock提供比内置锁更灵活的加锁方式，在JCU包中有较多应用。随着<code>synchronized</code>的性能优化，在简单加锁情况下，还是优选<code>synchronized</code>关键字，其使用简单且不需要显示释放，使用出错的几率较低。如果需要灵活的加锁策略（如上文有界缓存示例类）或需要超时机制等可以考虑使用重入锁，当需要尤其注意需要释放锁，推荐在<code>finally</code>代码块中释放锁，保证正常异常情况都能成功释放。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文在代码层面详细分析了重入锁主要函数实现，<code>ReentrantLock</code>实现了较为灵活的重入锁，对比内置<code>synchronized</code>关键字，不仅提供常规的加锁解锁操作，也提供了非阻塞获取锁及超时时间内获取锁的方法，并且通过<code>Conditon</code>对象提供灵活的线程间通信方式。但其使用比<code>synchronized</code>关键字复杂，且不能自动释放，且随着<code>synchronized</code>关键字性能的提升，故在只需要简单加锁时仍推荐使用<code>synchronized</code>关键字，在需要灵活的加锁策略时考虑使用<code>ReentrantLock</code></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 重入锁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入AQS]]></title>
      <url>/2018/04/07/%E6%B7%B1%E5%85%A5AQS/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AbstractQueuedSynchronizer一般简称AQS，是位于JUC包中的重要工具类，包括ReentrantLock、CountDownLatch等众多提供阻塞方法的类都是基于AQS进行编写的，理解AQS对于理解JUC包中许多类的实现都有极大的帮助。本文通过阅读AQS源码的方式，学习AQS实现的原理及技巧。下文主要包括以下几方面：  </p>
<ol>
<li>AQS总览；</li>
<li>AQS主要功能；</li>
<li>使用示例-排它锁<a id="more"></a>
</li>
</ol>
<h2 id="AQS总览"><a href="#AQS总览" class="headerlink" title="AQS总览"></a>AQS总览</h2><p>AQS在<code>java.util.concurrent.locks</code>包中，其UML图为：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/AbstractQueuedSynchronizer.png" alt=""><br>可见AQS继承于<code>AbstractOwnableSynchronizer</code>,并且其实现中包含了<code>Node</code>及<code>ConditionObject</code>两个内部类。<code>AbstractOwnableSynchronizer</code>类功能较为简单，不包括构造函数外只提供了两个方法：<code>setExclusiveOwnerThread</code>及<code>getExclusiveOwnerThread</code>，用于设置和获取当前对象所属的线程，需要注意在设置及获取当前对象所属线程时，该类并没有加锁使用时需要调用人员自行保证数据的一致性。  </p>
<h2 id="AQS主要功能"><a href="#AQS主要功能" class="headerlink" title="AQS主要功能"></a>AQS主要功能</h2><p>AQS类的文档中说明其主要作用为：  </p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.  </p>
</blockquote>
<p>简单说来就是提供一个实现基于FIFO队列的阻塞锁的框架，在使用中一般推荐继承AQS并实现以下几个方法完成同步逻辑：</p>
<ul>
<li>tryAcquire：线程尝试以排他方式获取锁；  </li>
<li>tryRelease：线程调用该方法释放排他锁；</li>
<li>tryAcquireShared：线程尝试以共享方式获取锁；  </li>
<li>tryReleaseShared：线程调用该方法释放共享锁；</li>
<li>isHeldExclusively：锁是否被排他方式占用   </li>
</ul>
<p>以上几个方法在AQS中均为进行实现，直接调用会抛出<code>UnsupportedOperationException</code>异常，需要子类根据自己的需求实现对应方法。<br>文字描述较为抽象，通过学习AQS文档中自带的代码深入学习</p>
<h2 id="使用示例-排它锁"><a href="#使用示例-排它锁" class="headerlink" title="使用示例-排它锁"></a>使用示例-排它锁</h2><p>以下代码引用自JDK8中的AQS类注释  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Reports whether in locked state</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Provides a Condition</span></span><br><span class="line">      <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Deserializes properly</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该类实现了一个互斥锁，实现了<code>Lock</code>接口，在实现过程中主要通过调用内部类<code>Sync</code>的对象<code>sync</code>完成相关工作。重点观察<code>Sync</code>，<code>Sync</code>继承了了<code>AbstractQueuedSynchronizer</code>，并实现了上文提到的5个方法中的3个，即<code>isHeldExclusively</code>、<code>tryAcquire</code>及<code>tryRelease</code>三个方法。  </p>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><p>当前线程调用<code>lock</code>方法请求锁时，实际上是调用了AQS的<code>acquire</code>函数，该函数代码为：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而该函数流程为：<br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/AbstractQueuedSynchronizer_acquire.png" alt=""> </p>
<h4 id="tryAcquire函数实现"><a href="#tryAcquire函数实现" class="headerlink" title="tryAcquire函数实现"></a><code>tryAcquire</code>函数实现</h4><p>其中<code>tryAcquire</code>函数为示例类<code>Mutex</code>实现， 根据以上代码该函数实现时调用<code>compareAndSetState</code>函数。其功能为使用CAS操作<strong>原子</strong>的设置对象中一个名为<code>state</code>的<code>int</code>型变量，传入两个<code>int</code>类型参数，分别为预期值及设置后的值，流程如下：<br> <img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/compareAndSetState.png" alt=""><br><code>compareAndSetState</code>是AQS关键函数之一，查看<code>compareAndSetState</code>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以发现<code>compareAndSetState</code>最终调用了<code>sun.misc.Unsafe</code>类的<code>compareAndSwapInt</code>方法，该函数可以原子性的设置属性，保证线程安全，该方法前两个参数分别为对象地址及偏移量，对象地址执行需要修改的对象，偏移量指定需要修改的整数类型数据在该对象中的内存地址，该函数实现是在Native方法中实现，查看该方法在OpenJdk9中的实现为(代码在：<strong>hotspot/src/share/vm/primsunsafe.cpp</strong>中)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e));</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>其中主要为调用<code>Atomic::cmpxchg</code>方法，该方法在不同平台实现略有不同，以下为mac平台实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value, cmpxchg_memory_order order) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"</span><br><span class="line">                    : <span class="string">"=a"</span> (exchange_value)</span><br><span class="line">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><br><span class="line">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下为windows实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value, cmpxchg_memory_order order) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见其中主要使用了c++代码中嵌入汇编代码的方式实现，并且使用宏<code>LOCK_IF_MP</code>判断是否为多核处理器，在是多核处理时会增加lock操作。到当前代码依然可以使用汇编的视角进行语句分析，本文在此就略去，不过有一点小细节可见在windows实现时使用了dword关键字，可见Java整形数据在内存中的确使用了32位进行存储。<br>返回对于<code>acquire</code>函数的研究，调用了<code>tryAcquire</code>后，具有两种情况：</p>
<ul>
<li>获取锁成功（将值从0设置为1）：<code>tryAcquire</code>函数继续调用<code>setExclusiveOwnerThread</code>函数将锁的所有者线程设置为当前线程，并返回<code>true</code>，<strong>注意</strong>此处有之前调用<code>compareAndSetState</code>函数，表明只可能有设置值成功的线程可调用<code>setExclusiveOwnerThread</code>函数，故可保证线程安全。</li>
<li>获取锁失败（期望设置的值不为0或设置时失败）：<code>tryAcquire</code>函数直接返回false。  </li>
</ul>
<p>在<code>tryAcquire</code>函数直接返回true后<code>acquire</code>函数不继续判断直接返回，则最上层的<code>lock</code>函数执行完毕，线程完成锁的申请，继续执行后续代码。<code>tryAcquire</code>函数直接返回false后，继续执行<code>acquireQueued</code>函数。  </p>
<h4 id="acquireQueued函数"><a href="#acquireQueued函数" class="headerlink" title="acquireQueued函数"></a><code>acquireQueued</code>函数</h4><p><code>tryAcquire</code>函数核心为尝试将<code>state</code>充0设置为1，在两种情况下可能返回失败：  </p>
<ol>
<li><code>state</code>已经不为0：已有其他线程获取锁；</li>
<li><code>state</code>为0：但同时多个线程同时调用<code>compareAndSwapInt</code>，当前线程竞争失败。  </li>
</ol>
<p>无论以上何种失败，在<code>tryAcquire</code>函数无法获取锁的情况下，继续进行<code>acquireQueued</code>函数函数的调用。在调用<code>acquireQueued</code>之前，函数会调用<code>addWaiter</code>将当前线程封装为节点对象，由于调用<code>acquire</code>函数获取的是排它锁，故调用<code>addWaiter</code>函数时传入创建节点类型为<code>Node.EXCLUSIVE</code>，<code>addWaiter</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>完成如下功能：  </p>
<ol>
<li>将当前线程封装到<code>Node</code>对象中；</li>
<li>获取当前AQS对象中等待队列的尾节点；</li>
<li>如果当前尾节点不为空：<br>a. 将新建节点的前置节点指向当前尾节点；<br>b. 尝试使用<code>compareAndSetTail</code>函数原子性的将当前<code>AQS</code>对象的尾节点指向新建节点，若指向成功，将原尾节点的后续节点指向新建节点，返回新建节点对象，由于<code>compareAndSetTail</code>函数保证有且只有一个线程能够设置成功，则后续<code>pred.next = node</code>语句能在逻辑上保证线程安全；<br>c. 若设置失败，继续调用<code>enq(node)</code>函数进行自旋.</li>
<li>如当前尾节点不存在或希望更新尾节点时失败，继续调用<code>enq(node)</code>函数。  </li>
</ol>
<p><code>enq(node)</code>函数主要使用自旋循环CAS方式更新当前队列的尾节点（在首次初始化时会将新建一不携带任何逻辑信息的头结点），此处不再详细展开。<br>完成<code>addWaiter</code>代码的调用后，保证当前封装当前线程的等待节点已经插入等待队列队尾，此时开始真正调用<code>acquireQueued</code>函数，其代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据代码分析：  </p>
<ol>
<li>取出刚加入队列的节点的前置节点，若前置节点为头结点则再次尝试获取锁，这么做的原因是在刚才获取锁失败到当前时刻，排在现在节点之前的等待节点可能被其他线程移除；</li>
<li>如获取锁成功，将当前节点设置为头结点，<strong>在设置时，需要将当前节点指向的线程及前置节点的属性都置为null，以帮助GC有机会快速收回不可达对象</strong>，之后进入<code>finally</code>块，最后返回<code>false</code>；</li>
<li>如果获取锁失败开始调用<code>shouldParkAfterFailedAcquire</code>函数  </li>
</ol>
<p>调用<code>shouldParkAfterFailedAcquire</code>函数需要传入参数包括当前节点及当前节点的前置结点，其逻辑如下：<br><!--  
![](http://p2amq694a.bkt.clouddn.com/JAVA/JUC/shouldParkAfterFailedAcquire.png?imageView2/0/w/600/h/600/q/100) --><br><img src="http://p2amq694a.bkt.clouddn.com/JAVA/JUC/shouldParkAfterFailedAcquire.png" alt=""><br><code>shouldParkAfterFailedAcquire</code>函数在前置节点状态不为<code>Node.SIGNAL</code>的状态下主要完成两件事：移除队列中所有状态值大于0的节点（如被取消的节点）；将前置节点状态设置为<code>Node.SIGNAL</code>。<br>继续<code>acquireQueued</code>函数的分析，在调用<code>shouldParkAfterFailedAcquire</code>函数后，若<code>shouldParkAfterFailedAcquire</code>返回false，则继续刚才的循环，知道获取锁或<code>shouldParkAfterFailedAcquire</code>函数返回true。由于前一次的函数调用将前置节点状态置为了<code>Node.SIGNAL</code>，再次调用<code>shouldParkAfterFailedAcquire</code>大概率情况下会返回true。<br>当<code>shouldParkAfterFailedAcquire</code>函数返回true后，<code>acquireQueued</code>函数继续调用<code>parkAndCheckInterrupt</code>函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数使用到了Jdk(从1.6开始)中提供的工具类方法<code>LockSupport.park(this)</code>，代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数作用设置当前线程的阻塞对象，并且调用<code>UNSAFE.park(false, 0L)</code>函数将当前线程设置为阻塞状态，让出CPU。<code>UNSAFE.park</code>函数在JVM的native方法中实现，查看JVM源码在Linux平台该函数最终主要使用了<code>pthread_cond_wait</code>及<code>pthread_cond_signal</code>两个函数进行线程的阻塞和唤醒，其中具体实现本文不再赘述。此处需要注意理论上<code>pthread_cond_signal</code>函数的调用仅仅会唤醒一个线程，不会出现<strong>惊群现象</strong>（即同时唤醒多个线程），但是在某些平台可能无法完全保证，所以<code>LockSupport.park</code>函数说明了三种停止阻塞并继续执行的情况：  </p>
<ol>
<li>Some other thread invokes unpark with the current thread as the target;     </li>
<li>Some other thread interrupts the current thread; </li>
<li>The call spuriously (that is, for no reason) returns.  </li>
</ol>
<p>其中第三种情况就可能是由<strong>惊群现象</strong>所引起。但由于本文中<code>acquireQueued</code>函数使用死循环的方式进行了判断，即使线程被意外唤醒，也可以再次判断其锁的状态，在无法获取锁的情况下会再次阻塞，不会出现逻辑问题。<br>在执行了<code>UNSAFE.park</code>函数后，当前线程进入阻塞状态，不再占用CPU资源(此处的线程调度可参考操作系统相关实现)。当前当前线程被唤醒后从<code>LockSupport.park</code>函数返回，并且通过<code>Thread.interrupted()</code>返回当前线程中断状态。之后继续在循环中继续判断是获取锁还是继续阻塞。这里需要注意由于<code>acquireQueued</code>并没有处理中断，其只会在正常获取锁后返回当前线程是否是由于中断被唤醒的，所以使用<code>acquireQueued</code>获取锁的线程不会因为中断而停止锁的获取。<br>最后如果在获取锁的过程出现异常，则会调用<code>cancelAcquire(node)</code>函数，<code>cancelAcquire</code>函数执行以下逻辑：  </p>
<ol>
<li>将当前节点指向的线程置为空；</li>
<li>设置指向前置节点的引用，跳过所有已经被取消的前驱节点；</li>
<li>将当前节点的状态置为已取消状态；</li>
<li>如果当前节点是尾节点，原子性的设置当前节点的前置节点为尾节点，并且将前置节点的后驱节点置为空；</li>
<li>如果当前节点不是尾节点，则判断当前节点的前置节点是不是头结点且前置节点状态为<code>Node.SIGNAL</code>则将前置节点的后置节点置为当前节点的后置置节点，否则调用<code>unparkSuccessor</code>函数唤醒后置节点。</li>
</ol>
<h4 id="锁获取总结"><a href="#锁获取总结" class="headerlink" title="锁获取总结"></a>锁获取总结</h4><p>到此为止通过分析<code>acquire</code>函数的实现，完成了<code>Mutex</code>类<code>lock</code>函数的实现的分析。在获取锁的过程中主要使用<code>AQS</code>相关功能，通过维护等待队列的方式完成线程的阻塞及唤醒。<strong>Mutex类是AQS注释中的示例类，不能应用在实际生产环境中，如以上加锁过程没有考虑重入问题，生产环境使用可能出现递归调用死锁问题</strong>  </p>
<h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>在线程执行完成临界区代码（或出现异常退出临界区时）需要调用<code>unlock</code>函数进行解锁以让出排他锁。通过对于示例代码的分析，解锁函数实际使用<code>sync.release</code>函数进行，该函数代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了方便观察，将<code>tryRelease</code>函数也展示出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">  <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  setState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁函数较为简单，当前的<code>Mutex</code>类假设使用锁的代码都是按照先加锁再解锁的顺序进行执行，所以在此情况下能保证同一时刻有且只有一个线程能够执行<code>unlock</code>函数，故解锁过程非常简单且不需要同步：  </p>
<ol>
<li>获取锁的状态，如果锁的状态为0，则表示目前没有加锁，抛出异常；</li>
<li>将当前锁记录的拥有锁的线程置为空；</li>
<li>将锁的状态置为0；</li>
<li>获取当前等待队列头结点，如头结点不为空且其等待状态不为0则唤醒头结点的后置节点</li>
</ol>
<p>到此则释放锁的过程结束。<strong>Mutex类是AQS注释中的示例类，不能应用在实际生产环境中，如以上解锁过程就没有判断当前解锁的线程是不是已经得到锁的线程，这在生产环境中可能出现未知的问题</strong></p>
<h3 id="排它锁总结"><a href="#排它锁总结" class="headerlink" title="排它锁总结"></a>排它锁总结</h3><p>本节分析了使用AQS进行实现互斥锁的方法，并深入AQS代码分析其实现原理。重点分析其加锁及解锁过程，其他锁方法类似，本处不在赘述。针对其他重要方法、共享锁及<code>Condition</code>类的分析后续结合JCU包中关联类进行。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> AbstractQueuedSynchronizer </tag>
            
            <tag> AQS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序采坑记录]]></title>
      <url>/2018/03/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="微信小程序采坑记录"><a href="#微信小程序采坑记录" class="headerlink" title="微信小程序采坑记录"></a>微信小程序采坑记录</h1><p>最近在学习微信小程序开发，本文用于记录开发中踩得坑<br><a id="more"></a></p>
<h2 id="scroll-view删除坑"><a href="#scroll-view删除坑" class="headerlink" title="scroll-view删除坑"></a>scroll-view删除坑</h2><h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><p>在列表中使用scroll-view，使用<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html" target="_blank" rel="noopener">wx:for</a>指令进行渲染，每一行为一个scroll-view，在右侧增加删除功能，日常显示如下：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view.png" alt=""><br>使用向左滑动后展示如下：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view%E5%88%A0%E9%99%A4%E5%89%8D.png" alt=""><br>这是点击删除按钮，js使用setData更新列表数据，预期为删除本行，下三行自动上移，但实际情况却是下三行自动上移，但其中第一行却是滑动后状态，具体如图：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view%E5%88%A0%E9%99%A4%E5%90%8E.png" alt=""></p>
<h3 id="问题解决（临时措施）"><a href="#问题解决（临时措施）" class="headerlink" title="问题解决（临时措施）"></a>问题解决（临时措施）</h3><p>在scroll-view中有一个scroll-left属性可以设置，目前解决方案为每次更新重新设置scroll-left为0。</p>
]]></content>
      
        <categories>
            
            <category> 微信小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA栈溢出]]></title>
      <url>/2018/01/14/JAVA%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<h2 id="Java栈溢出小记"><a href="#Java栈溢出小记" class="headerlink" title="Java栈溢出小记"></a>Java栈溢出小记</h2><p>今天偶然有人问起如何在编写Java代码使其在运行时抛出栈溢出异常，看似简单的问题涉及到了Java虚拟机的知识，特记录于此文。<br><a id="more"></a></p>
<h2 id="Java虚拟机结构简介"><a href="#Java虚拟机结构简介" class="headerlink" title="Java虚拟机结构简介"></a>Java虚拟机结构简介</h2><p>根据《Java虚拟机规范》<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">(The Java Virtual Machine Specification)</a>对于Java虚拟机运行时数据区域<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">(Run-Time Data Areas)</a>的描述，虚拟机运行时的描述，其构成图如下所示:<img src="http://p2amq694a.bkt.clouddn.com/JAVA/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt=""><br>图中，PC寄存器、Java虚拟机栈及本地方法栈为各线程私有，方法区（包括运行时常量取）及堆为线程间共享的存储空间。针对问题提出的栈溢出，有两个区域与其相关，包括Java虚拟机栈及本地方法栈。查阅《Java虚拟机规范》，针对栈溢出有如下两段描述：<br>对于Java虚拟机栈</p>
<blockquote>
<p>The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<ul>
<li>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</li>
<li>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</li>
</ul>
</blockquote>
<p>对于本地方法栈</p>
<blockquote>
<p>The following exceptional conditions are associated with native method stacks:</p>
<ul>
<li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</li>
<li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</li>
</ul>
</blockquote>
<p>由此可见对于Java虚拟机栈与本地方法栈都定义了相似的两种溢出：</p>
<ol>
<li>线程请求栈上分配内存时，内存不足：此溢出一般出现在线程递归调用方法时。在线程调用方法时虚拟机创建<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">栈帧</a>保存方法调用信息，在方法调用完成后销毁栈帧释放存储，如果在方法调用过程中无法创建栈帧则会报出StackOverflowError异常。</li>
<li>动态扩展栈或线程创建时无法分配足够内存：此溢出一般出现在创建新的线程时。创建新的线程，需要在栈上为其分配存储，如果此时栈上存储不足以分配则会报出OutOfMemoryError异常。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下代码在Mac版JDK8中实现及运行，由于HotSpot实现中没有分Java虚拟机栈及本地方法栈<sup><a href="#reference-doc">[1]</a></sup>，故以下代码只针对Java虚拟机栈。Hotspot中设置栈容量的参数为<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">-Xss</a>，后续实验均设置-Xss1M，使用Junit4进行测试</p>
<h3 id="分配栈帧失败（StackOverflowError）"><a href="#分配栈帧失败（StackOverflowError）" class="headerlink" title="分配栈帧失败（StackOverflowError）"></a>分配栈帧失败（StackOverflowError）</h3><p>代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        System.out.println(depth);</span><br><span class="line">        callMyself(++depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StackOverflow overflow = <span class="keyword">new</span> StackOverflow();</span><br><span class="line">        overflow.callMyself(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会抛出java.lang.StackOverflowError，且最终能够达到的栈深度主要与栈内存最大大小与栈帧中局部变量占用的空间有关。使用如下代码最大深度会明显变小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e,f,g,h,i,j,k;</span><br><span class="line">        System.out.println(depth+<span class="string">"|"</span>);</span><br><span class="line">        callMyself(++depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为线程分配栈上内存失败（OutOfMemoryError）"><a href="#为线程分配栈上内存失败（OutOfMemoryError）" class="headerlink" title="为线程分配栈上内存失败（OutOfMemoryError）"></a>为线程分配栈上内存失败（OutOfMemoryError）</h3><p>代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createThread</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        OutOfMemory outOfMemory = <span class="keyword">new</span> OutOfMemory();</span><br><span class="line">        outOfMemory.createThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会抛出OutOfMemoryError。</p>
<h2 id="针对于OutOfMemoryError的补充"><a href="#针对于OutOfMemoryError的补充" class="headerlink" title="针对于OutOfMemoryError的补充"></a>针对于OutOfMemoryError的补充</h2><p>在HotSpot虚拟机实现中，对于Java线程的创建是映射到操作系统线程中的，如果无法创建操作系统线程也会抛出异常，具体为:<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。<br>通过实验在MacOS中，一般小于2048（多次测试为2023），因为默认Mac每个进程最多分配的线程数为2048。可使用<code>sysctl kern.num_taskthreads</code>命令进行查询。如果需要突破限制可以参考<a href="https://support.apple.com/en-us/HT202528" target="_blank" rel="noopener">官方解决方案</a>。<br>在centOS中实验发现<em>max_user_processes</em>及<em>stack size</em>参数都会限制各进程的线程数量。</p>
<p><span id="reference-doc">参考文献</span><br>[1] 周志明.深入理解Java虚拟机[M].北京:机械工业出版社,53</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA虚拟机 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[感知机对偶形式学习]]></title>
      <url>/2017/12/21/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="总结感知机及其对偶形式"><a href="#总结感知机及其对偶形式" class="headerlink" title="总结感知机及其对偶形式"></a>总结感知机及其对偶形式</h1><a id="more"></a>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>实际应用中常出现二元分类问题，如引用台湾大学机器学习基石课程<sup><a href="#reference-doc">[1]</a></sup>的信用卡案例：如有用户申请信用卡，其个人信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">数据</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">年龄</td>
<td style="text-align:center">23</td>
</tr>
<tr>
<td style="text-align:center">性别</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">年收入</td>
<td style="text-align:center">1，000，000</td>
</tr>
<tr>
<td style="text-align:center">居住年限</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">工作年限</td>
<td style="text-align:center">0.5</td>
</tr>
<tr>
<td style="text-align:center">负债</td>
<td style="text-align:center">200，000</td>
</tr>
</tbody>
</table>
<p>银行具有原来的信用卡申请记录（包括申请用户信息及审批结果），如何根据原来的记录判断当前申请是否能够批准就是一个典型的二分问题。输入数据为个人信息，训练数据为历史申请及审批记录，输出数据为是否同意申请。<br>假设银行根据申请用户的各项信息（特征）为用户打分，并且设定一个阈值，在用户得分超过该阈值则同意信用卡申请，否则拒绝申请。<br>故假设用户具m个特征为<br>$$x=({x_1,x_2,\cdots,x_m})$$<br>得分阈值为$d$。每个特征对于最终的用户得分有不同的重要程度，所以为每一个特征增加入不同的权值$w=({w_1,w_2,\cdots,w_m})$，用户最终得分为<br>$$w_1x_1+w_2x_2+ \cdots +w_mx_m=\sum_{i=1}^{m}w_ix_i$$<br>最后只需要比较 $\sum_{i=1}^{m}w_ix_i$与阈值$d$的大小就可以得出结果。<br>观察上文公式，如何确定每一个信息的权值$w$及同意申请的阈值$d$就是解决问题的关键，由于具有历史数据，使用历史数据确定参数的想法就水到渠成。</p>
<h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p>根据上文背景问题的提出，可进行抽象，银行n笔已知的数据可以抽象为训练数据集<br>$$T={(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)}$$<br>其中$x\in\chi ,\chi\subseteq R^m$，$y\in\mathcal{Y}={+1,-1}$。<br>设上文求和公式及阈值之差为函数<br>$$h(x)=\sum_{i=1}^{m}w_ix_i-d$$<br>为简化公式取$b=-d$，则公式变化为：<br>$$h(x)=\sum_{i=1}^{m}w_ix_i+b$$<br>改写为向量形式为:<br>$$h(x)=w\cdot x+b$$<br>当$h(x)&gt;0$时，发放信用卡，否则拒绝发放信用卡<br>使用取符号的函数$sign$，得到函数<br>$$f(x)=sign(w\cdot x+b)$$<br>此函数为感知机算法需要学习得到的最终函数。</p>
<h2 id="感知机介绍"><a href="#感知机介绍" class="headerlink" title="感知机介绍"></a>感知机介绍</h2><p>感知机1957年由<a href="https://en.wikipedia.org/wiki/Frank_Rosenblatt" target="_blank" rel="noopener">Rosenblatt</a>提出，是支持向量机及神经网络基础算法。<br>感知机主要通过训练数据集学习函数：<br>$$f(x)=sign(w\cdot x+b)$$<br>中的模型参数$w$及$b$，其中$x\in\chi ,\chi\subseteq R^m,w\in R^m,b\in R$。感知机算法要求训练集是<strong>线性可分</strong>，当训练集线性可分时可以证明感知机算法可以通过有限次的搜索找到将训练集完全区分的超平面，否则感知机算法将不会收敛<sup><a href="#reference-doc">[2]</a></sup>。</p>
<p><strong>未完待续</strong></p>
<p><span id="reference-doc">参考文献</span><br>[1] 林轩田.机器学习基石[R].台湾:台湾大学.<br>[2] 李航.统计学习方法[M].北京:清华大学出版社,2012:26-33.</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> 李航 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java.util.concurrent.locks.Lock详解]]></title>
      <url>/2017/10/23/java-util-concurrent-locks-Lock%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java.util.concurrent.locks.Lock接口（以下简称Lock）作者<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>，对比使用synchronized关键字进行并发控制，Lock接口的实现类可以完成更灵活的加锁操作。<br>本文以下会详细介绍Lock接口相关功能，并对比Lock接口及synchronized关键字在功能上（非性能对比）的异同。<br><a id="more"></a></p>
<h2 id="Lock接口相关功能介绍"><a href="#Lock接口相关功能介绍" class="headerlink" title="Lock接口相关功能介绍"></a>Lock接口相关功能介绍</h2><p><img src="http://ohvbq3urs.bkt.clouddn.com/techblog/java/concurrent/lock-struct.png" alt=""><br>如图所示，Lock接口定义6个方法:</p>
<div id="lock"></div>

<ol>
<li>lock:尝试获取锁，如当前线程无法获取锁，则当前线程进入无法调度的休眠状态，直到获取锁。</li>
<li>lockInterruptibly:    与 <a href="#lock">lock</a>相似，主要区别在于调用该方法后，如无法获取锁，则当前线程进入无法调度的休眠状态，直到出现以下两种情况:<br> <em>. 获取锁；
 </em>. 当前线程被其他线程中断。</li>
<li>tryLock:    尝试获取锁，但与lock不同，不会阻塞线程调用后立刻返回，能够获取锁返回true，否则返回false</li>
<li>tryLock(long,TimeUnit):    尝试获取锁，可传入超时参数，在以下3种情况下返回：<ul>
<li>在等待时间内获取锁；</li>
<li>在等待时间被其他线程中断，抛出中断异常；</li>
<li>等待时间结束，返回false</li>
</ul>
</li>
<li>unlock:释放锁</li>
<li>newCondition:创建一个Condition对象，此对象另开专题讨论。</li>
</ol>
<h2 id="Lock接口及synchronized关键字对比"><a href="#Lock接口及synchronized关键字对比" class="headerlink" title="Lock接口及synchronized关键字对比"></a>Lock接口及synchronized关键字对比</h2><p><strong>synchronized</strong>作为Java语言的并发控制关键字，在多线程编程中十分常用，主要有三种使用方式：</p>
<ol>
<li>修饰对象方法；</li>
<li>修饰静态方法；</li>
<li>修饰同步方法快。</li>
</ol>
<p>使用synchronized关键字可以完成对访问共享资源的代码块的显示加锁和隐式释放锁。在代码离开synchronized关键字修饰的区域后，synchronized自动释放锁定，其优势主要为：</p>
<ol>
<li>JVM内置锁结构，使用简单；</li>
<li>不需要手动释放，不会出现程序员忘记释放的认为失误；</li>
<li>可以受到JVM厂商的底层优化。<br>其主要缺点为：<ol>
<li>性能一般低于Lock接口的实现类（随着优化的进行，这个性能差距正在极大的缩小）；</li>
<li>灵活性不足，对于较为复杂的加锁操作无法进行支持。</li>
</ol>
</li>
</ol>
<p><strong>Lock</strong>接口将加锁及解锁操作控制权都交给程序员，这增加了锁的灵活性却也增加了出现逻辑问题的可能性。<br>由此可见，在由于当前synchronized关键字不断得到JVM优化，在仅仅需求简单同步操作时可以优先考虑synchronized关键字，在有灵活加锁操作的需求时再考虑使用Lock接口的各实现类，并且需要谨慎使用，尤其不能忘记锁的释放。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Lock接口的各方法含义，并且简单对比了Lock及synchronized关键字的异同。后续计划继续对于synchronized关键字的实现的研究，及Lock接口各典型实现的研究。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWriteArrayList学习总结]]></title>
      <url>/2017/10/17/CopyOnWriteArrayList%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CopyOnWriteArrayList类位于java.util.concurrent包，JDK1.5引入，作者为<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>。CopyOnWriteArrayList是一个线程安全的List，使用“写时复制”的思想在进行所有写入操作（增加、删除等）是都会进行内部存储元素数组的复制。<br><a id="more"></a></p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="写时过程"><a href="#写时过程" class="headerlink" title="写时过程"></a>写时过程</h3><p>由于采用写时复制的策略，其主要作用过程在于对存储数据进行修改时。以add函数为例。一下为JDK8中实现源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>进入函数首先获取ReentrantLock重入锁；</li>
<li>获取当前对象中实际存储数据的Objecte数组；</li>
<li>复制当前数组并且将数组长度扩展1；</li>
<li>将新数据插入当前数组的最后一位；</li>
<li>将指向原数组的变量置为指向新数组，释放锁，完成工作。</li>
</ol>
<h3 id="对比ArrayList"><a href="#对比ArrayList" class="headerlink" title="对比ArrayList"></a>对比ArrayList</h3><p>增加元素代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过查看代码可知，ArrayList在写入时是没有加锁的，所以多线程情况下使用并不安全，需要程序员手动进行并发控制。引用源码中说明为：</p>
<blockquote>
<p>Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be “wrapped” using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list:<br>List list = Collections.synchronizedList(new ArrayList(…));</p>
</blockquote>
<p>验证ArrayList线程不安全可使用以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(List&lt;String&gt; list, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)&#123;</span><br><span class="line">                list.add(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(list, countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行过程中<strong>大概率</strong>会出现Java.lang.ArrayIndexOutOfBoundsException错误</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>使用CopyOnWriteArrayList可以不用进行手动同步控制，并且由于使用了读写分离的措施，在进行写入时可以同时进行数据的读取，并且数据读取过程中不需要加锁。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>根据其实现代码，CopyOnWriteArrayList的缺点同样明显。首先、其每次写入都需要进行数组的复制，所以对于写入操作非常消耗系统资源，尤其是内存资源，这种情况在处理存储较多数据的List时尤其明显。对于gc也造成了较大压力。其次，由于其在读取时不需要获取锁，造成如写入数据同时进行读取可能造成读取到的数据为旧数组中的数据，可能造成数据的不一致。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>由此可见，CopyOnWriteArrayList比较适合用在大量读取小量写入的场景，并且要求系统对于数据的不一致宽容度较高。<br>针对写时复制的策略，在必须要进行写入时尽量将多次写入合并为一次写入，减少数组复制次数。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 同步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring @Autowired+@Qualifier与@Resource的区别]]></title>
      <url>/2016/06/02/Spring%20@Autowired+@Qualifier%E4%B8%8E@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>最近由于希望使用Spring在XML文件中定义List的bean，并使用@Autowired进行注入到对象中使用，遇到到一些坑，记录一下作为备忘。<br><a id="more"></a></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired是Spring定义的注解，是根据<strong>类型</strong>进行自动装配的。如果当spring上下文中存在不止一个存在一个需要装配类型的bean时，就会抛出BeanCreationException异常;这时我们可以使用@Qualifier配合@Autowired来解决问题。</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource是JSR-250规定的注解，主要有两种类型的属性type及name，所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入<a href="http://blog.csdn.net/clerk0324/article/details/25198457" target="_blank" rel="noopener">策略</a> 。<br>@Resource装配顺序:</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li>
</ol>
<h3 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h3><p>使用Spring注入List的时候在XML中定义:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10.1.200.104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10.1.200.205<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后使用注解注入，代码1为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入失败。修改，代码2为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ArrayList&lt;String&gt; strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入仍然失败。修改，代码3为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">'myList'</span>)</span><br><span class="line">    ArrayList&lt;String&gt; strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然失败。主要原因在于，使用Autowired注入，Spring默认使用按类型方式注入，而对于List集合类型Spring会读取其中的泛型类型进行注入，上面代码2的含义为注入当前bean中类型为String的对象，代码3的含义为注入当前bean中类型为String且qualifier是myList的对象。这两种含义都不能完成正确的注入。</p>
<h3 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用"></a>正确使用</h3><p><strong>使用@Resource注入</strong>,<a href="http://stackoverflow.com/questions/1363310/auto-wiring-a-list-using-util-schema-gives-nosuchbeandefinitionexception" target="_blank" rel="noopener">引用stackoverflow上的解答</a>使用正确方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"myList"</span>)</span><br><span class="line">    ArrayList&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"myList"</span>)</span><br><span class="line">    List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Resource设置了name属性，Spring直接寻找id为myList的对象进行注入，可以注入成功。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> @Autowired </tag>
            
            <tag> @Qualifier </tag>
            
            <tag> @Resource List </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[微信小程序采坑记录]]></title>
      <url>/2018/03/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="微信小程序采坑记录"><a href="#微信小程序采坑记录" class="headerlink" title="微信小程序采坑记录"></a>微信小程序采坑记录</h1><p>最近在学习微信小程序开发，本文用于记录开发中踩得坑<br><a id="more"></a></p>
<h2 id="scroll-view删除坑"><a href="#scroll-view删除坑" class="headerlink" title="scroll-view删除坑"></a>scroll-view删除坑</h2><h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><p>在列表中使用scroll-view，使用<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html" target="_blank" rel="noopener">wx:for</a>指令进行渲染，每一行为一个scroll-view，在右侧增加删除功能，日常显示如下：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view.png" alt=""><br>使用向左滑动后展示如下：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view%E5%88%A0%E9%99%A4%E5%89%8D.png" alt=""><br>这是点击删除按钮，js使用setData更新列表数据，预期为删除本行，下三行自动上移，但实际情况却是下三行自动上移，但其中第一行却是滑动后状态，具体如图：<br><img src="http://p2amq694a.bkt.clouddn.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/scroll-view%E5%88%A0%E9%99%A4%E5%90%8E.png" alt=""></p>
<h3 id="问题解决（临时措施）"><a href="#问题解决（临时措施）" class="headerlink" title="问题解决（临时措施）"></a>问题解决（临时措施）</h3><p>在scroll-view中有一个scroll-left属性可以设置，目前解决方案为每次更新重新设置scroll-left为0。</p>
]]></content>
      
        <categories>
            
            <category> 微信小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA栈溢出]]></title>
      <url>/2018/01/14/JAVA%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<h2 id="Java栈溢出小记"><a href="#Java栈溢出小记" class="headerlink" title="Java栈溢出小记"></a>Java栈溢出小记</h2><p>今天偶然有人问起如何在编写Java代码使其在运行时抛出栈溢出异常，看似简单的问题涉及到了Java虚拟机的知识，特记录于此文。<br><a id="more"></a></p>
<h2 id="Java虚拟机结构简介"><a href="#Java虚拟机结构简介" class="headerlink" title="Java虚拟机结构简介"></a>Java虚拟机结构简介</h2><p>根据《Java虚拟机规范》<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">(The Java Virtual Machine Specification)</a>对于Java虚拟机运行时数据区域<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">(Run-Time Data Areas)</a>的描述，虚拟机运行时的描述，其构成图如下所示:<img src="http://p2amq694a.bkt.clouddn.com/JAVA/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt=""><br>图中，PC寄存器、Java虚拟机栈及本地方法栈为各线程私有，方法区（包括运行时常量取）及堆为线程间共享的存储空间。针对问题提出的栈溢出，有两个区域与其相关，包括Java虚拟机栈及本地方法栈。查阅《Java虚拟机规范》，针对栈溢出有如下两段描述：<br>对于Java虚拟机栈</p>
<blockquote>
<p>The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<ul>
<li>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</li>
<li>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</li>
</ul>
</blockquote>
<p>对于本地方法栈</p>
<blockquote>
<p>The following exceptional conditions are associated with native method stacks:</p>
<ul>
<li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</li>
<li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</li>
</ul>
</blockquote>
<p>由此可见对于Java虚拟机栈与本地方法栈都定义了相似的两种溢出：</p>
<ol>
<li>线程请求栈上分配内存时，内存不足：此溢出一般出现在线程递归调用方法时。在线程调用方法时虚拟机创建<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">栈帧</a>保存方法调用信息，在方法调用完成后销毁栈帧释放存储，如果在方法调用过程中无法创建栈帧则会报出StackOverflowError异常。</li>
<li>动态扩展栈或线程创建时无法分配足够内存：此溢出一般出现在创建新的线程时。创建新的线程，需要在栈上为其分配存储，如果此时栈上存储不足以分配则会报出OutOfMemoryError异常。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下代码在Mac版JDK8中实现及运行，由于HotSpot实现中没有分Java虚拟机栈及本地方法栈<sup><a href="#reference-doc">[1]</a></sup>，故以下代码只针对Java虚拟机栈。Hotspot中设置栈容量的参数为<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">-Xss</a>，后续实验均设置-Xss1M，使用Junit4进行测试</p>
<h3 id="分配栈帧失败（StackOverflowError）"><a href="#分配栈帧失败（StackOverflowError）" class="headerlink" title="分配栈帧失败（StackOverflowError）"></a>分配栈帧失败（StackOverflowError）</h3><p>代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        System.out.println(depth);</span><br><span class="line">        callMyself(++depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StackOverflow overflow = <span class="keyword">new</span> StackOverflow();</span><br><span class="line">        overflow.callMyself(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会抛出java.lang.StackOverflowError，且最终能够达到的栈深度主要与栈内存最大大小与栈帧中局部变量占用的空间有关。使用如下代码最大深度会明显变小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMyself</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e,f,g,h,i,j,k;</span><br><span class="line">        System.out.println(depth+<span class="string">"|"</span>);</span><br><span class="line">        callMyself(++depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为线程分配栈上内存失败（OutOfMemoryError）"><a href="#为线程分配栈上内存失败（OutOfMemoryError）" class="headerlink" title="为线程分配栈上内存失败（OutOfMemoryError）"></a>为线程分配栈上内存失败（OutOfMemoryError）</h3><p>代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createThread</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        OutOfMemory outOfMemory = <span class="keyword">new</span> OutOfMemory();</span><br><span class="line">        outOfMemory.createThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会抛出OutOfMemoryError。</p>
<h2 id="针对于OutOfMemoryError的补充"><a href="#针对于OutOfMemoryError的补充" class="headerlink" title="针对于OutOfMemoryError的补充"></a>针对于OutOfMemoryError的补充</h2><p>在HotSpot虚拟机实现中，对于Java线程的创建是映射到操作系统线程中的，如果无法创建操作系统线程也会抛出异常，具体为:<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。<br>通过实验在MacOS中，一般小于2048（多次测试为2023），因为默认Mac每个进程最多分配的线程数为2048。可使用<code>sysctl kern.num_taskthreads</code>命令进行查询。如果需要突破限制可以参考<a href="https://support.apple.com/en-us/HT202528" target="_blank" rel="noopener">官方解决方案</a>。<br>在centOS中实验发现<em>max_user_processes</em>及<em>stack size</em>参数都会限制各进程的线程数量。</p>
<p><span id="reference-doc">参考文献</span><br>[1] 周志明.深入理解Java虚拟机[M].北京:机械工业出版社,53</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA虚拟机 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[感知机对偶形式学习]]></title>
      <url>/2017/12/21/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="总结感知机及其对偶形式"><a href="#总结感知机及其对偶形式" class="headerlink" title="总结感知机及其对偶形式"></a>总结感知机及其对偶形式</h1><a id="more"></a>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>实际应用中常出现二元分类问题，如引用台湾大学机器学习基石课程<sup><a href="#reference-doc">[1]</a></sup>的信用卡案例：如有用户申请信用卡，其个人信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">数据</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">年龄</td>
<td style="text-align:center">23</td>
</tr>
<tr>
<td style="text-align:center">性别</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">年收入</td>
<td style="text-align:center">1，000，000</td>
</tr>
<tr>
<td style="text-align:center">居住年限</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">工作年限</td>
<td style="text-align:center">0.5</td>
</tr>
<tr>
<td style="text-align:center">负债</td>
<td style="text-align:center">200，000</td>
</tr>
</tbody>
</table>
<p>银行具有原来的信用卡申请记录（包括申请用户信息及审批结果），如何根据原来的记录判断当前申请是否能够批准就是一个典型的二分问题。输入数据为个人信息，训练数据为历史申请及审批记录，输出数据为是否同意申请。<br>假设银行根据申请用户的各项信息（特征）为用户打分，并且设定一个阈值，在用户得分超过该阈值则同意信用卡申请，否则拒绝申请。<br>故假设用户具m个特征为<br>$$x=({x_1,x_2,\cdots,x_m})$$<br>得分阈值为$d$。每个特征对于最终的用户得分有不同的重要程度，所以为每一个特征增加入不同的权值$w=({w_1,w_2,\cdots,w_m})$，用户最终得分为<br>$$w_1x_1+w_2x_2+ \cdots +w_mx_m=\sum_{i=1}^{m}w_ix_i$$<br>最后只需要比较 $\sum_{i=1}^{m}w_ix_i$与阈值$d$的大小就可以得出结果。<br>观察上文公式，如何确定每一个信息的权值$w$及同意申请的阈值$d$就是解决问题的关键，由于具有历史数据，使用历史数据确定参数的想法就水到渠成。</p>
<h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p>根据上文背景问题的提出，可进行抽象，银行n笔已知的数据可以抽象为训练数据集<br>$$T={(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)}$$<br>其中$x\in\chi ,\chi\subseteq R^m$，$y\in\mathcal{Y}={+1,-1}$。<br>设上文求和公式及阈值之差为函数<br>$$h(x)=\sum_{i=1}^{m}w_ix_i-d$$<br>为简化公式取$b=-d$，则公式变化为：<br>$$h(x)=\sum_{i=1}^{m}w_ix_i+b$$<br>改写为向量形式为:<br>$$h(x)=w\cdot x+b$$<br>当$h(x)&gt;0$时，发放信用卡，否则拒绝发放信用卡<br>使用取符号的函数$sign$，得到函数<br>$$f(x)=sign(w\cdot x+b)$$<br>此函数为感知机算法需要学习得到的最终函数。</p>
<h2 id="感知机介绍"><a href="#感知机介绍" class="headerlink" title="感知机介绍"></a>感知机介绍</h2><p>感知机1957年由<a href="https://en.wikipedia.org/wiki/Frank_Rosenblatt" target="_blank" rel="noopener">Rosenblatt</a>提出，是支持向量机及神经网络基础算法。<br>感知机主要通过训练数据集学习函数：<br>$$f(x)=sign(w\cdot x+b)$$<br>中的模型参数$w$及$b$，其中$x\in\chi ,\chi\subseteq R^m,w\in R^m,b\in R$。感知机算法要求训练集是<strong>线性可分</strong>，当训练集线性可分时可以证明感知机算法可以通过有限次的搜索找到将训练集完全区分的超平面，否则感知机算法将不会收敛<sup><a href="#reference-doc">[2]</a></sup>。</p>
<p><strong>未完待续</strong></p>
<p><span id="reference-doc">参考文献</span><br>[1] 林轩田.机器学习基石[R].台湾:台湾大学.<br>[2] 李航.统计学习方法[M].北京:清华大学出版社,2012:26-33.</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> 李航 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java.util.concurrent.locks.Lock详解]]></title>
      <url>/2017/10/23/java-util-concurrent-locks-Lock%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java.util.concurrent.locks.Lock接口（以下简称Lock）作者<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>，对比使用synchronized关键字进行并发控制，Lock接口的实现类可以完成更灵活的加锁操作。<br>本文以下会详细介绍Lock接口相关功能，并对比Lock接口及synchronized关键字在功能上（非性能对比）的异同。<br><a id="more"></a></p>
<h2 id="Lock接口相关功能介绍"><a href="#Lock接口相关功能介绍" class="headerlink" title="Lock接口相关功能介绍"></a>Lock接口相关功能介绍</h2><p><img src="http://ohvbq3urs.bkt.clouddn.com/techblog/java/concurrent/lock-struct.png" alt=""><br>如图所示，Lock接口定义6个方法:</p>
<div id="lock"></div>

<ol>
<li>lock:尝试获取锁，如当前线程无法获取锁，则当前线程进入无法调度的休眠状态，直到获取锁。</li>
<li>lockInterruptibly:    与 <a href="#lock">lock</a>相似，主要区别在于调用该方法后，如无法获取锁，则当前线程进入无法调度的休眠状态，直到出现以下两种情况:<br> <em>. 获取锁；
 </em>. 当前线程被其他线程中断。</li>
<li>tryLock:    尝试获取锁，但与lock不同，不会阻塞线程调用后立刻返回，能够获取锁返回true，否则返回false</li>
<li>tryLock(long,TimeUnit):    尝试获取锁，可传入超时参数，在以下3种情况下返回：<ul>
<li>在等待时间内获取锁；</li>
<li>在等待时间被其他线程中断，抛出中断异常；</li>
<li>等待时间结束，返回false</li>
</ul>
</li>
<li>unlock:释放锁</li>
<li>newCondition:创建一个Condition对象，此对象另开专题讨论。</li>
</ol>
<h2 id="Lock接口及synchronized关键字对比"><a href="#Lock接口及synchronized关键字对比" class="headerlink" title="Lock接口及synchronized关键字对比"></a>Lock接口及synchronized关键字对比</h2><p><strong>synchronized</strong>作为Java语言的并发控制关键字，在多线程编程中十分常用，主要有三种使用方式：</p>
<ol>
<li>修饰对象方法；</li>
<li>修饰静态方法；</li>
<li>修饰同步方法快。</li>
</ol>
<p>使用synchronized关键字可以完成对访问共享资源的代码块的显示加锁和隐式释放锁。在代码离开synchronized关键字修饰的区域后，synchronized自动释放锁定，其优势主要为：</p>
<ol>
<li>JVM内置锁结构，使用简单；</li>
<li>不需要手动释放，不会出现程序员忘记释放的认为失误；</li>
<li>可以受到JVM厂商的底层优化。<br>其主要缺点为：<ol>
<li>性能一般低于Lock接口的实现类（随着优化的进行，这个性能差距正在极大的缩小）；</li>
<li>灵活性不足，对于较为复杂的加锁操作无法进行支持。</li>
</ol>
</li>
</ol>
<p><strong>Lock</strong>接口将加锁及解锁操作控制权都交给程序员，这增加了锁的灵活性却也增加了出现逻辑问题的可能性。<br>由此可见，在由于当前synchronized关键字不断得到JVM优化，在仅仅需求简单同步操作时可以优先考虑synchronized关键字，在有灵活加锁操作的需求时再考虑使用Lock接口的各实现类，并且需要谨慎使用，尤其不能忘记锁的释放。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Lock接口的各方法含义，并且简单对比了Lock及synchronized关键字的异同。后续计划继续对于synchronized关键字的实现的研究，及Lock接口各典型实现的研究。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 同步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWriteArrayList学习总结]]></title>
      <url>/2017/10/17/CopyOnWriteArrayList%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CopyOnWriteArrayList类位于java.util.concurrent包，JDK1.5引入，作者为<a href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin" target="_blank" rel="noopener">Doug Lea</a>。CopyOnWriteArrayList是一个线程安全的List，使用“写时复制”的思想在进行所有写入操作（增加、删除等）是都会进行内部存储元素数组的复制。<br><a id="more"></a></p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="写时过程"><a href="#写时过程" class="headerlink" title="写时过程"></a>写时过程</h3><p>由于采用写时复制的策略，其主要作用过程在于对存储数据进行修改时。以add函数为例。一下为JDK8中实现源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>进入函数首先获取ReentrantLock重入锁；</li>
<li>获取当前对象中实际存储数据的Objecte数组；</li>
<li>复制当前数组并且将数组长度扩展1；</li>
<li>将新数据插入当前数组的最后一位；</li>
<li>将指向原数组的变量置为指向新数组，释放锁，完成工作。</li>
</ol>
<h3 id="对比ArrayList"><a href="#对比ArrayList" class="headerlink" title="对比ArrayList"></a>对比ArrayList</h3><p>增加元素代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过查看代码可知，ArrayList在写入时是没有加锁的，所以多线程情况下使用并不安全，需要程序员手动进行并发控制。引用源码中说明为：</p>
<blockquote>
<p>Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be “wrapped” using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list:<br>List list = Collections.synchronizedList(new ArrayList(…));</p>
</blockquote>
<p>验证ArrayList线程不安全可使用以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(List&lt;String&gt; list, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)&#123;</span><br><span class="line">                list.add(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(list, countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行过程中<strong>大概率</strong>会出现Java.lang.ArrayIndexOutOfBoundsException错误</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>使用CopyOnWriteArrayList可以不用进行手动同步控制，并且由于使用了读写分离的措施，在进行写入时可以同时进行数据的读取，并且数据读取过程中不需要加锁。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>根据其实现代码，CopyOnWriteArrayList的缺点同样明显。首先、其每次写入都需要进行数组的复制，所以对于写入操作非常消耗系统资源，尤其是内存资源，这种情况在处理存储较多数据的List时尤其明显。对于gc也造成了较大压力。其次，由于其在读取时不需要获取锁，造成如写入数据同时进行读取可能造成读取到的数据为旧数组中的数据，可能造成数据的不一致。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>由此可见，CopyOnWriteArrayList比较适合用在大量读取小量写入的场景，并且要求系统对于数据的不一致宽容度较高。<br>针对写时复制的策略，在必须要进行写入时尽量将多次写入合并为一次写入，减少数组复制次数。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 同步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring @Autowired+@Qualifier与@Resource的区别]]></title>
      <url>/2016/06/02/Spring%20@Autowired+@Qualifier%E4%B8%8E@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>最近由于希望使用Spring在XML文件中定义List的bean，并使用@Autowired进行注入到对象中使用，遇到到一些坑，记录一下作为备忘。<br><a id="more"></a></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired是Spring定义的注解，是根据<strong>类型</strong>进行自动装配的。如果当spring上下文中存在不止一个存在一个需要装配类型的bean时，就会抛出BeanCreationException异常;这时我们可以使用@Qualifier配合@Autowired来解决问题。</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource是JSR-250规定的注解，主要有两种类型的属性type及name，所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入<a href="http://blog.csdn.net/clerk0324/article/details/25198457" target="_blank" rel="noopener">策略</a> 。<br>@Resource装配顺序:</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li>
</ol>
<h3 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h3><p>使用Spring注入List的时候在XML中定义:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10.1.200.104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10.1.200.205<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后使用注解注入，代码1为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入失败。修改，代码2为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ArrayList&lt;String&gt; strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入仍然失败。修改，代码3为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">'myList'</span>)</span><br><span class="line">    ArrayList&lt;String&gt; strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然失败。主要原因在于，使用Autowired注入，Spring默认使用按类型方式注入，而对于List集合类型Spring会读取其中的泛型类型进行注入，上面代码2的含义为注入当前bean中类型为String的对象，代码3的含义为注入当前bean中类型为String且qualifier是myList的对象。这两种含义都不能完成正确的注入。</p>
<h3 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用"></a>正确使用</h3><p><strong>使用@Resource注入</strong>,<a href="http://stackoverflow.com/questions/1363310/auto-wiring-a-list-using-util-schema-gives-nosuchbeandefinitionexception" target="_blank" rel="noopener">引用stackoverflow上的解答</a>使用正确方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"myList"</span>)</span><br><span class="line">    ArrayList&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"myList"</span>)</span><br><span class="line">    List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Resource设置了name属性，Spring直接寻找id为myList的对象进行注入，可以注入成功。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> @Autowired </tag>
            
            <tag> @Qualifier </tag>
            
            <tag> @Resource List </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

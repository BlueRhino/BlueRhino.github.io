<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入AQS]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%B7%B1%E5%85%A5AQS%2F</url>
    <content type="text"><![CDATA[简介AbstractQueuedSynchronizer一般简称AQS，是位于JUC包中的重要工具类，包括ReentrantLock、CountDownLatch等众多提供阻塞方法的类都是基于AQS进行编写的，理解AQS对于理解JUC包中许多类的实现都有极大的帮助。本文通过阅读AQS源码的方式，学习AQS实现的原理及技巧。下文主要包括以下几方面： AQS总览； AQS主要功能； 使用示例-排它锁 AQS总览AQS在java.util.concurrent.locks包中，其UML图为：可见AQS继承于AbstractOwnableSynchronizer,并且其实现中包含了Node及ConditionObject两个内部类。AbstractOwnableSynchronizer类功能较为简单，不包括构造函数外只提供了两个方法：setExclusiveOwnerThread及getExclusiveOwnerThread，用于设置和获取当前对象所属的线程，需要注意在设置及获取当前对象所属线程时，该类并没有加锁使用时需要调用人员自行保证数据的一致性。 AQS主要功能AQS类的文档中说明其主要作用为： Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. 简单说来就是提供一个实现基于FIFO队列的阻塞锁的框架，在使用中一般推荐继承AQS并实现以下几个方法完成同步逻辑： tryAcquire：线程尝试以排他方式获取锁； tryRelease：线程调用该方法释放排他锁； tryAcquireShared：线程尝试以共享方式获取锁； tryReleaseShared：线程调用该方法释放共享锁； isHeldExclusively：锁是否被排他方式占用 以上几个方法在AQS中均为进行实现，直接调用会抛出UnsupportedOperationException异常，需要子类根据自己的需求实现对应方法。文字描述较为抽象，通过学习AQS文档中自带的代码深入学习 使用示例-排它锁以下代码引用自JDK8中的AQS类注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Mutex implements Lock, java.io.Serializable &#123; // Our internal helper class private static class Sync extends AbstractQueuedSynchronizer &#123; // Reports whether in locked state protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // Acquires the lock if state is zero public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // Releases the lock by setting state to zero protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // Provides a Condition Condition newCondition() &#123; return new ConditionObject(); &#125; // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; &#125; 该类实现了一个互斥锁，实现了Lock接口，在实现过程中主要通过调用内部类Sync的对象sync完成相关工作。重点观察Sync，Sync继承了了AbstractQueuedSynchronizer，并实现了上文提到的5个方法中的3个，即isHeldExclusively、tryAcquire及tryRelease三个方法。 加锁过程当前线程调用lock方法请求锁时，实际上是调用了AQS的acquire函数，该函数代码为： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 而该函数流程为： tryAcquire函数实现其中tryAcquire函数为示例类Mutex实现， 根据以上代码该函数实现时调用compareAndSetState函数使用CAS方式尝试将锁的状态设置为1，成功则返回true，失败则说明当前互斥锁已经被获取，则返回false。compareAndSetState是AQS关键函数之一，查看compareAndSetState源码：1234protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; 从代码可以发现compareAndSetState最终调用了sun.misc.Unsafe类的compareAndSwapInt方法，该函数可以原子性的设置属性，保证线程安全，该方法前两个参数分别为对象地址及偏移量，对象地址执行需要修改的对象，偏移量指定需要修改的整数类型数据在该对象中的内存地址，该函数实现是在Native方法中实现，查看该方法在OpenJdk9中的实现为(代码在：hotspot/src/share/vm/primsunsafe.cpp中)： 123456UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123; oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e));&#125; UNSAFE_END 其中主要为调用Atomic::cmpxchg方法，该方法在不同平台实现略有不同，以下为mac平台实现： 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value, cmpxchg_memory_order order) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)" : "=a" (exchange_value) : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp) : "cc", "memory"); return exchange_value;&#125; 以下为windows实现： 1234567891011inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value, cmpxchg_memory_order order) &#123; // alternative for InterlockedCompareExchange int mp = os::is_MP(); __asm &#123; mov edx, dest mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) cmpxchg dword ptr [edx], ecx &#125;&#125; 可见其中主要使用了c++代码中嵌入汇编代码的方式实现，并且使用宏LOCK_IF_MP判断是否为多核处理器，在是多核处理时会增加lock操作。到当前代码依然可以使用汇编的视角进行语句分析，本文在此就略去，不过有一点小细节可见在windows实现时使用了dword关键字，可见Java整形数据在内存中的确使用了32位进行存储。返回对于acquire函数的研究，调用了tryAcquire后，具有两种情况： 获取锁成功（将值从0设置为1）：tryAcquire函数继续调用setExclusiveOwnerThread函数将锁的所有者线程设置为当前线程，并返回true，注意此处有之前调用compareAndSetState函数，表明只可能有设置值成功的线程可调用setExclusiveOwnerThread函数，故可保证线程安全。 获取锁失败（期望设置的值不为0或设置时失败）：tryAcquire函数直接返回false。 在tryAcquire函数直接返回true后acquire函数不继续判断直接返回，则最上层的lock函数执行完毕，线程完成锁的申请，继续执行后续代码。tryAcquire函数直接返回false后，继续执行acquireQueued函数。 acquireQueued函数tryAcquire函数核心为尝试将state充0设置为1，在两种情况下可能返回失败： state已经不为0：已有其他线程获取锁； state为0：但同时多个线程同时调用compareAndSwapInt，当前线程竞争失败。 无论以上何种失败，在tryAcquire函数无法获取锁的情况下，继续进行acquireQueued函数函数的调用。在调用acquireQueued之前，函数会调用addWaiter将当前线程封装为节点对象，由于调用acquire函数获取的是排它锁，故调用addWaiter函数时传入创建节点类型为Node.EXCLUSIVE，addWaiter代码如下：1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; 完成如下功能： 将当前线程封装到Node对象中； 获取当前AQS对象中等待队列的尾节点； 如果当前尾节点不为空：a. 将新建节点的前置节点指向当前尾节点；b. 尝试使用compareAndSetTail函数原子性的将当前AQS对象的尾节点指向新建节点，若指向成功，将原尾节点的后续节点指向新建节点，返回新建节点对象，由于compareAndSetTail函数保证有且只有一个线程能够设置成功，则后续pred.next = node语句能在逻辑上保证线程安全；c. 若设置失败，继续调用enq(node)函数进行自旋. 如当前尾节点不存在或希望更新尾节点时失败，继续调用enq(node)函数。 enq(node)函数主要使用自旋循环CAS方式更新当前队列的尾节点（在首次初始化时会将新建一不携带任何逻辑信息的头结点），此处不再详细展开。完成addWaiter代码的调用后，保证当前封装当前线程的等待节点已经插入等待队列队尾，此时开始真正调用acquireQueued函数，其代码为：123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 根据代码分析： 取出刚加入队列的节点的前置节点，若前置节点为头结点则再次尝试获取锁，这么做的原因是在刚才获取锁失败到当前时刻，排在现在节点之前的等待节点可能被其他线程移除； 如获取锁成功，将当前节点设置为头结点，在设置时，需要将当前节点指向的线程及前置节点的属性都置为null，以帮助GC有机会快速收回不可达对象，之后进入finally块，最后返回false； 如果获取锁失败开始调用shouldParkAfterFailedAcquire函数 调用shouldParkAfterFailedAcquire函数需要传入参数包括当前节点及当前节点的前置结点，其逻辑如下：shouldParkAfterFailedAcquire函数在前置节点状态不为Node.SIGNAL的状态下主要完成两件事：移除队列中所有状态值大于0的节点（如被取消的节点）；将前置节点状态设置为Node.SIGNAL。继续acquireQueued函数的分析，在调用shouldParkAfterFailedAcquire函数后，若shouldParkAfterFailedAcquire返回false，则继续刚才的循环，知道获取锁或shouldParkAfterFailedAcquire函数返回true。由于前一次的函数调用将前置节点状态置为了Node.SIGNAL，再次调用shouldParkAfterFailedAcquire大概率情况下会返回true。当shouldParkAfterFailedAcquire函数返回true后，acquireQueued函数继续调用parkAndCheckInterrupt函数。1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; 该函数使用到了Jdk(从1.6开始)中提供的工具类方法LockSupport.park(this)，代码为：123456public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); &#125; 该函数作用设置当前线程的阻塞对象，并且调用UNSAFE.park(false, 0L)函数将当前线程设置为阻塞状态，让出CPU。UNSAFE.park函数在JVM的native方法中实现，查看JVM源码在Linux平台该函数最终主要使用了pthread_cond_wait及pthread_cond_signal两个函数进行线程的阻塞和唤醒，其中具体实现本文不再赘述。此处需要注意理论上pthread_cond_signal函数的调用仅仅会唤醒一个线程，不会出现惊群现象（即同时唤醒多个线程），但是在某些平台可能无法完全保证，所以LockSupport.park函数说明了三种停止阻塞并继续执行的情况： Some other thread invokes unpark with the current thread as the target; Some other thread interrupts the current thread; The call spuriously (that is, for no reason) returns. 其中第三种情况就可能是由惊群现象所引起。但由于本文中acquireQueued函数使用死循环的方式进行了判断，即使线程被意外唤醒，也可以再次判断其锁的状态，在无法获取锁的情况下会再次阻塞，不会出现逻辑问题。在执行了UNSAFE.park函数后，当前线程进入阻塞状态，不再占用CPU资源(此处的线程调度可参考操作系统相关实现)。当前当前线程被唤醒后从LockSupport.park函数返回，并且通过Thread.interrupted()返回当前线程中断状态。之后继续在循环中继续判断是获取锁还是继续阻塞。这里需要注意由于acquireQueued并没有处理中断，其只会在正常获取锁后返回当前线程是否是由于中断被唤醒的，所以使用acquireQueued获取锁的线程不会因为中断而停止锁的获取。最后如果在获取锁的过程出现异常，则会调用cancelAcquire(node)函数，cancelAcquire函数执行以下逻辑： 将当前节点指向的线程置为空； 设置指向前置节点的引用，跳过所有已经被取消的前驱节点； 将当前节点的状态置为已取消状态； 如果当前节点是尾节点，原子性的设置当前节点的前置节点为尾节点，并且将前置节点的后驱节点置为空； 如果当前节点不是尾节点，则判断当前节点的前置节点是不是头结点且前置节点状态为Node.SIGNAL则将前置节点的后置节点置为当前节点的后置置节点，否则调用unparkSuccessor函数唤醒后置节点。 锁获取总结到此为止通过分析acquire函数的实现，完成了Mutex类lock函数的实现的分析。在获取锁的过程中主要使用AQS相关功能，通过维护等待队列的方式完成线程的阻塞及唤醒。Mutex类是AQS注释中的示例类，不能应用在实际生产环境中，如以上加锁过程没有考虑重入问题，生产环境使用可能出现递归调用死锁问题 解锁过程在线程执行完成临界区代码（或出现异常退出临界区时）需要调用unlock函数进行解锁以让出排他锁。通过对于示例代码的分析，解锁函数实际使用sync.release函数进行，该函数代码为：123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; 为了方便观察，将tryRelease函数也展示出来： 1234567protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true;&#125; 解锁函数较为简单，当前的Mutex类假设使用锁的代码都是按照先加锁再解锁的顺序进行执行，所以在此情况下能保证同一时刻有且只有一个线程能够执行unlock函数，故解锁过程非常简单且不需要同步： 获取锁的状态，如果锁的状态为0，则表示目前没有加锁，抛出异常； 将当前锁记录的拥有锁的线程置为空； 将锁的状态置为0； 获取当前等待队列头结点，如头结点不为空且其等待状态不为0则唤醒头结点的后置节点 到此则释放锁的过程结束。Mutex类是AQS注释中的示例类，不能应用在实际生产环境中，如以上解锁过程就没有判断当前解锁的线程是不是已经得到锁的线程，这在生产环境中可能出现未知的问题 排它锁总结本节分析了使用AQS进行实现互斥锁的方法，并深入AQS代码分析其实现原理。重点分析其加锁及解锁过程，其他锁方法类似，本处不在赘述。针对共享锁及Condition类的分析后续结合JCU包中生成类进行。]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AbstractQueuedSynchronizer</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序采坑记录]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[微信小程序采坑记录最近在学习微信小程序开发，本文用于记录开发中踩得坑 scroll-view删除坑情景重现在列表中使用scroll-view，使用wx:for指令进行渲染，每一行为一个scroll-view，在右侧增加删除功能，日常显示如下：使用向左滑动后展示如下：这是点击删除按钮，js使用setData更新列表数据，预期为删除本行，下三行自动上移，但实际情况却是下三行自动上移，但其中第一行却是滑动后状态，具体如图： 问题解决（临时措施）在scroll-view中有一个scroll-left属性可以设置，目前解决方案为每次更新重新设置scroll-left为0。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA栈溢出]]></title>
    <url>%2F2018%2F01%2F14%2FJAVA%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Java栈溢出小记今天偶然有人问起如何在编写Java代码使其在运行时抛出栈溢出异常，看似简单的问题涉及到了Java虚拟机的知识，特记录于此文。 Java虚拟机结构简介根据《Java虚拟机规范》(The Java Virtual Machine Specification)对于Java虚拟机运行时数据区域(Run-Time Data Areas)的描述，虚拟机运行时的描述，其构成图如下所示:图中，PC寄存器、Java虚拟机栈及本地方法栈为各线程私有，方法区（包括运行时常量取）及堆为线程间共享的存储空间。针对问题提出的栈溢出，有两个区域与其相关，包括Java虚拟机栈及本地方法栈。查阅《Java虚拟机规范》，针对栈溢出有如下两段描述：对于Java虚拟机栈 The following exceptional conditions are associated with Java Virtual Machine stacks: If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError. If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError. 对于本地方法栈 The following exceptional conditions are associated with native method stacks: If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a StackOverflowError. If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError. 由此可见对于Java虚拟机栈与本地方法栈都定义了相似的两种溢出： 线程请求栈上分配内存时，内存不足：此溢出一般出现在线程递归调用方法时。在线程调用方法时虚拟机创建栈帧保存方法调用信息，在方法调用完成后销毁栈帧释放存储，如果在方法调用过程中无法创建栈帧则会报出StackOverflowError异常。 动态扩展栈或线程创建时无法分配足够内存：此溢出一般出现在创建新的线程时。创建新的线程，需要在栈上为其分配存储，如果此时栈上存储不足以分配则会报出OutOfMemoryError异常。 代码实现以下代码在Mac版JDK8中实现及运行，由于HotSpot实现中没有分Java虚拟机栈及本地方法栈[1]，故以下代码只针对Java虚拟机栈。Hotspot中设置栈容量的参数为-Xss，后续实验均设置-Xss1M，使用Junit4进行测试 分配栈帧失败（StackOverflowError）代码为：12345678910111213141516public class StackOverflow &#123; public void callMyself(int depth) &#123; System.out.println(depth); callMyself(++depth); &#125;&#125;public class StackOverflowTest &#123; @Test public void callMyself() throws Exception &#123; StackOverflow overflow = new StackOverflow(); overflow.callMyself(0); &#125;&#125; 最终会抛出java.lang.StackOverflowError，且最终能够达到的栈深度主要与栈内存最大大小与栈帧中局部变量占用的空间有关。使用如下代码最大深度会明显变小12345678public class StackOverflow &#123; public void callMyself(int depth) &#123; int a,b,c,d,e,f,g,h,i,j,k; System.out.println(depth+"|"); callMyself(++depth); &#125;&#125; 为线程分配栈上内存失败（OutOfMemoryError）代码为：1234567891011121314151617181920public class OutOfMemory &#123; public void createThread() &#123; while (true) &#123; Thread t = new Thread(() -&gt; &#123; while (true) &#123; System.out.println(System.currentTimeMillis()); &#125; &#125;); t.start(); &#125; &#125;&#125;public class OutOfMemoryTest &#123; @Test public void createThread() throws Exception &#123; OutOfMemory outOfMemory = new OutOfMemory(); outOfMemory.createThread(); &#125;&#125; 最终会抛出OutOfMemoryError。 针对于OutOfMemoryError的补充在HotSpot虚拟机实现中，对于Java线程的创建是映射到操作系统线程中的，如果无法创建操作系统线程也会抛出异常，具体为:java.lang.OutOfMemoryError: unable to create new native thread。通过实验在MacOS中，一般小于2048（多次测试为2023），因为默认Mac每个进程最多分配的线程数为2048。可使用sysctl kern.num_taskthreads命令进行查询。如果需要突破限制可以参考官方解决方案。在centOS中实验发现max_user_processes及stack size参数都会限制各进程的线程数量。 参考文献[1] 周志明.深入理解Java虚拟机[M].北京:机械工业出版社,53]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
        <tag>JAVA虚拟机</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感知机对偶形式学习]]></title>
    <url>%2F2017%2F12%2F21%2F%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[总结感知机及其对偶形式 问题背景实际应用中常出现二元分类问题，如引用台湾大学机器学习基石课程[1]的信用卡案例：如有用户申请信用卡，其个人信息如下： 特征 数据 年龄 23 性别 女 年收入 1，000，000 居住年限 1 工作年限 0.5 负债 200，000 银行具有原来的信用卡申请记录（包括申请用户信息及审批结果），如何根据原来的记录判断当前申请是否能够批准就是一个典型的二分问题。输入数据为个人信息，训练数据为历史申请及审批记录，输出数据为是否同意申请。假设银行根据申请用户的各项信息（特征）为用户打分，并且设定一个阈值，在用户得分超过该阈值则同意信用卡申请，否则拒绝申请。故假设用户具m个特征为$$x=({x_1,x_2,\cdots,x_m})$$得分阈值为$d$。每个特征对于最终的用户得分有不同的重要程度，所以为每一个特征增加入不同的权值$w=({w_1,w_2,\cdots,w_m})$，用户最终得分为$$w_1x_1+w_2x_2+ \cdots +w_mx_m=\sum_{i=1}^{m}w_ix_i$$最后只需要比较 $\sum_{i=1}^{m}w_ix_i$与阈值$d$的大小就可以得出结果。观察上文公式，如何确定每一个信息的权值$w$及同意申请的阈值$d$就是解决问题的关键，由于具有历史数据，使用历史数据确定参数的想法就水到渠成。 问题抽象根据上文背景问题的提出，可进行抽象，银行n笔已知的数据可以抽象为训练数据集$$T={(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)}$$其中$x\in\chi ,\chi\subseteq R^m$，$y\in\mathcal{Y}={+1,-1}$。设上文求和公式及阈值之差为函数$$h(x)=\sum_{i=1}^{m}w_ix_i-d$$为简化公式取$b=-d$，则公式变化为：$$h(x)=\sum_{i=1}^{m}w_ix_i+b$$改写为向量形式为:$$h(x)=w\cdot x+b$$当$h(x)&gt;0$时，发放信用卡，否则拒绝发放信用卡使用取符号的函数$sign$，得到函数$$f(x)=sign(w\cdot x+b)$$此函数为感知机算法需要学习得到的最终函数。 感知机介绍感知机1957年由Rosenblatt提出，是支持向量机及神经网络基础算法。感知机主要通过训练数据集学习函数：$$f(x)=sign(w\cdot x+b)$$中的模型参数$w$及$b$，其中$x\in\chi ,\chi\subseteq R^m,w\in R^m,b\in R$。感知机算法要求训练集是线性可分，当训练集线性可分时可以证明感知机算法可以通过有限次的搜索找到将训练集完全区分的超平面，否则感知机算法将不会收敛[2]。 未完待续 参考文献[1] 林轩田.机器学习基石[R].台湾:台湾大学.[2] 李航.统计学习方法[M].北京:清华大学出版社,2012:26-33.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>感知机</tag>
        <tag>统计学习方法</tag>
        <tag>李航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent.locks.Lock详解]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-util-concurrent-locks-Lock%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介java.util.concurrent.locks.Lock接口（以下简称Lock）作者Doug Lea，对比使用synchronized关键字进行并发控制，Lock接口的实现类可以完成更灵活的加锁操作。本文以下会详细介绍Lock接口相关功能，并对比Lock接口及synchronized关键字在功能上（非性能对比）的异同。 Lock接口相关功能介绍如图所示，Lock接口定义6个方法: lock:尝试获取锁，如当前线程无法获取锁，则当前线程进入无法调度的休眠状态，直到获取锁。 lockInterruptibly: 与 lock相似，主要区别在于调用该方法后，如无法获取锁，则当前线程进入无法调度的休眠状态，直到出现以下两种情况: . 获取锁； . 当前线程被其他线程中断。 tryLock: 尝试获取锁，但与lock不同，不会阻塞线程调用后立刻返回，能够获取锁返回true，否则返回false tryLock(long,TimeUnit): 尝试获取锁，可传入超时参数，在以下3种情况下返回： 在等待时间内获取锁； 在等待时间被其他线程中断，抛出中断异常； 等待时间结束，返回false unlock:释放锁 newCondition:创建一个Condition对象，此对象另开专题讨论。 Lock接口及synchronized关键字对比synchronized作为Java语言的并发控制关键字，在多线程编程中十分常用，主要有三种使用方式： 修饰对象方法； 修饰静态方法； 修饰同步方法快。 使用synchronized关键字可以完成对访问共享资源的代码块的显示加锁和隐式释放锁。在代码离开synchronized关键字修饰的区域后，synchronized自动释放锁定，其优势主要为： JVM内置锁结构，使用简单； 不需要手动释放，不会出现程序员忘记释放的认为失误； 可以受到JVM厂商的底层优化。其主要缺点为： 性能一般低于Lock接口的实现类（随着优化的进行，这个性能差距正在极大的缩小）； 灵活性不足，对于较为复杂的加锁操作无法进行支持。 Lock接口将加锁及解锁操作控制权都交给程序员，这增加了锁的灵活性却也增加了出现逻辑问题的可能性。由此可见，在由于当前synchronized关键字不断得到JVM优化，在仅仅需求简单同步操作时可以优先考虑synchronized关键字，在有灵活加锁操作的需求时再考虑使用Lock接口的各实现类，并且需要谨慎使用，尤其不能忘记锁的释放。 总结本文主要介绍了Lock接口的各方法含义，并且简单对比了Lock及synchronized关键字的异同。后续计划继续对于synchronized关键字的实现的研究，及Lock接口各典型实现的研究。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CopyOnWriteArrayList学习总结]]></title>
    <url>%2F2017%2F10%2F17%2FCopyOnWriteArrayList%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介CopyOnWriteArrayList类位于java.util.concurrent包，JDK1.5引入，作者为Doug Lea。CopyOnWriteArrayList是一个线程安全的List，使用“写时复制”的思想在进行所有写入操作（增加、删除等）是都会进行内部存储元素数组的复制。 代码分析写时过程由于采用写时复制的策略，其主要作用过程在于对存储数据进行修改时。以add函数为例。一下为JDK8中实现源码：1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 进入函数首先获取ReentrantLock重入锁； 获取当前对象中实际存储数据的Objecte数组； 复制当前数组并且将数组长度扩展1； 将新数据插入当前数组的最后一位； 将指向原数组的变量置为指向新数组，释放锁，完成工作。 对比ArrayList增加元素代码：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 通过查看代码可知，ArrayList在写入时是没有加锁的，所以多线程情况下使用并不安全，需要程序员手动进行并发控制。引用源码中说明为： Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be “wrapped” using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list:List list = Collections.synchronizedList(new ArrayList(…)); 验证ArrayList线程不安全可使用以下代码12345678910111213141516171819202122232425262728293031323334public class Main &#123; static class AddThread implements Runnable &#123; private List&lt;String&gt; list; private CountDownLatch countDownLatch; public AddThread(List&lt;String&gt; list, CountDownLatch countDownLatch) &#123; this.list = list; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); for(int i=0;i&lt;500;i++)&#123; list.add("1"); &#125; &#125; &#125; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(1); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 200; i++) &#123; new Thread(new AddThread(list, countDownLatch)).start(); &#125; countDownLatch.countDown(); &#125;&#125; 运行过程中大概率会出现Java.lang.ArrayIndexOutOfBoundsException错误 优点使用CopyOnWriteArrayList可以不用进行手动同步控制，并且由于使用了读写分离的措施，在进行写入时可以同时进行数据的读取，并且数据读取过程中不需要加锁。 缺点根据其实现代码，CopyOnWriteArrayList的缺点同样明显。首先、其每次写入都需要进行数组的复制，所以对于写入操作非常消耗系统资源，尤其是内存资源，这种情况在处理存储较多数据的List时尤其明显。对于gc也造成了较大压力。其次，由于其在读取时不需要获取锁，造成如写入数据同时进行读取可能造成读取到的数据为旧数组中的数据，可能造成数据的不一致。 使用场景由此可见，CopyOnWriteArrayList比较适合用在大量读取小量写入的场景，并且要求系统对于数据的不一致宽容度较高。针对写时复制的策略，在必须要进行写入时尽量将多次写入合并为一次写入，减少数组复制次数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring @Autowired+@Qualifier与@Resource的区别]]></title>
    <url>%2F2016%2F06%2F02%2FSpring%20%40Autowired%2B%40Qualifier%E4%B8%8E%40Resource%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近由于希望使用Spring在XML文件中定义List的bean，并使用@Autowired进行注入到对象中使用，遇到到一些坑，记录一下作为备忘。 @Autowired@Autowired是Spring定义的注解，是根据类型进行自动装配的。如果当spring上下文中存在不止一个存在一个需要装配类型的bean时，就会抛出BeanCreationException异常;这时我们可以使用@Qualifier配合@Autowired来解决问题。 @Resource@Resource是JSR-250规定的注解，主要有两种类型的属性type及name，所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略 。@Resource装配顺序: 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； 使用区别使用Spring注入List的时候在XML中定义: 1234&lt;util:list id="myList"&gt; &lt;value&gt;10.1.200.104&lt;/value&gt; &lt;value&gt;10.1.200.205&lt;/value&gt;&lt;/util:list&gt; 之后使用注解注入，代码1为： 12345@Componentpublic class App &#123; @Autowired List list;&#125; 注入失败。修改，代码2为： 12345@Componentpublic class App &#123; @Autowired ArrayList&lt;String&gt; strings;&#125; 注入仍然失败。修改，代码3为： 123456@Componentpublic class App &#123; @Autowired @Qualifier('myList') ArrayList&lt;String&gt; strings;&#125; 仍然失败。主要原因在于，使用Autowired注入，Spring默认使用按类型方式注入，而对于List集合类型Spring会读取其中的泛型类型进行注入，上面代码2的含义为注入当前bean中类型为String的对象，代码3的含义为注入当前bean中类型为String且qualifier是myList的对象。这两种含义都不能完成正确的注入。 正确使用使用@Resource注入,引用stackoverflow上的解答使用正确方式为： 1234567@Componentpublic class App &#123; @Resource(name = "myList") ArrayList&lt;Object&gt; list;&#125; 或者 1234567@Componentpublic class App &#123; @Resource(name = "myList") List&lt;Object&gt; list;&#125; 因为Resource设置了name属性，Spring直接寻找id为myList的对象进行注入，可以注入成功。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>@Autowired</tag>
        <tag>@Qualifier</tag>
        <tag>@Resource List</tag>
      </tags>
  </entry>
</search>
